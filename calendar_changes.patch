diff --git a/server/database/migrations/add_calendar_feature.sql b/server/database/migrations/add_calendar_feature.sql
new file mode 100644
index 0000000..855887b
--- /dev/null
+++ b/server/database/migrations/add_calendar_feature.sql
@@ -0,0 +1,41 @@
+-- Add calendar_system feature to the features table
+-- Migration created on 2025-05-22
+
+INSERT INTO features (
+    code, 
+    name, 
+    description, 
+    category, 
+    base_price,
+    is_active
+) VALUES (
+    'calendar_system',
+    'Firmenkalender',
+    'Integrierter Firmenkalender für firmeneigene, abteilungs- und teamspezifische Termine und Veranstaltungen.',
+    'premium',
+    15.00,
+    1
+) ON DUPLICATE KEY UPDATE
+    name = VALUES(name),
+    description = VALUES(description),
+    category = VALUES(category),
+    base_price = VALUES(base_price),
+    is_active = VALUES(is_active);
+
+-- Aktivieren für Standard-Tenant (für Entwicklungszwecke)
+INSERT INTO tenant_features (
+    tenant_id,
+    feature_code,
+    is_active,
+    usage_limit,
+    expiry_date
+) VALUES (
+    1,
+    'calendar_system',
+    1,
+    1000,
+    DATE_ADD(CURRENT_DATE, INTERVAL 1 YEAR)
+) ON DUPLICATE KEY UPDATE
+    is_active = VALUES(is_active),
+    usage_limit = VALUES(usage_limit),
+    expiry_date = VALUES(expiry_date);
\ No newline at end of file
diff --git a/server/database/migrations/calendar_schema.sql b/server/database/migrations/calendar_schema.sql
new file mode 100644
index 0000000..f4c9d73
--- /dev/null
+++ b/server/database/migrations/calendar_schema.sql
@@ -0,0 +1,66 @@
+-- Calendar System Tables
+-- Migration created on 2025-05-22
+
+-- Calendar Events Table
+CREATE TABLE IF NOT EXISTS calendar_events (
+  id INT AUTO_INCREMENT PRIMARY KEY,
+  tenant_id INT NOT NULL,
+  title VARCHAR(255) NOT NULL,
+  description TEXT,
+  location VARCHAR(255),
+  start_time DATETIME NOT NULL,
+  end_time DATETIME NOT NULL,
+  all_day BOOLEAN DEFAULT FALSE,
+  org_level ENUM('company', 'department', 'team') NOT NULL,
+  org_id INT NOT NULL,  -- ID der Firma, Abteilung oder des Teams
+  created_by INT NOT NULL,
+  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
+  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
+  status ENUM('active', 'cancelled') DEFAULT 'active',
+  reminder_time INT,  -- Minuten vor Event für Erinnerung
+  color VARCHAR(20) DEFAULT '#3498db',  -- Event-Farbe für UI-Darstellung
+  FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
+  FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE CASCADE,
+  INDEX (tenant_id),
+  INDEX (org_level, org_id),
+  INDEX (start_time, end_time),
+  INDEX (status)
+);
+
+-- Calendar Attendees Table
+CREATE TABLE IF NOT EXISTS calendar_attendees (
+  id INT AUTO_INCREMENT PRIMARY KEY,
+  event_id INT NOT NULL,
+  user_id INT NOT NULL,
+  response_status ENUM('pending', 'accepted', 'declined', 'tentative') DEFAULT 'pending',
+  responded_at TIMESTAMP NULL,
+  notification_sent BOOLEAN DEFAULT FALSE,
+  FOREIGN KEY (event_id) REFERENCES calendar_events(id) ON DELETE CASCADE,
+  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
+  UNIQUE KEY (event_id, user_id),
+  INDEX (user_id)
+);
+
+-- Calendar Reminders Table (für zukünftige Benachrichtigungserweiterungen)
+CREATE TABLE IF NOT EXISTS calendar_reminders (
+  id INT AUTO_INCREMENT PRIMARY KEY,
+  event_id INT NOT NULL,
+  remind_time DATETIME NOT NULL,
+  is_sent BOOLEAN DEFAULT FALSE,
+  FOREIGN KEY (event_id) REFERENCES calendar_events(id) ON DELETE CASCADE,
+  INDEX (remind_time),
+  INDEX (is_sent)
+);
+
+-- Calendar Recurring Rules Table (für wiederkehrende Termine)
+CREATE TABLE IF NOT EXISTS calendar_recurring_rules (
+  id INT AUTO_INCREMENT PRIMARY KEY,
+  event_id INT NOT NULL,
+  frequency ENUM('daily', 'weekly', 'monthly', 'yearly') NOT NULL,
+  interval_value INT DEFAULT 1,
+  weekdays VARCHAR(20),  -- CSV der Wochentage (1-7)
+  month_day INT,         -- Spezifischer Tag im Monat
+  end_date DATE,         -- Enddatum der Wiederholung
+  count INT,             -- Anzahl der Wiederholungen
+  FOREIGN KEY (event_id) REFERENCES calendar_events(id) ON DELETE CASCADE
+);
\ No newline at end of file
diff --git a/server/models/calendar.js b/server/models/calendar.js
new file mode 100644
index 0000000..dcf243e
--- /dev/null
+++ b/server/models/calendar.js
@@ -0,0 +1,686 @@
+/**
+ * Calendar Model
+ * Handles database operations for the calendar events and attendees
+ */
+
+const db = require('../database');
+const User = require('./user');
+
+/**
+ * Get all calendar events visible to the user
+ * @param {number} tenantId - Tenant ID
+ * @param {number} userId - User ID
+ * @param {Object} options - Query options
+ * @param {string} options.status - Event status (active, cancelled)
+ * @param {string} options.filter - Filter by org_level (company, department, team)
+ * @param {string} options.search - Search term for title/description
+ * @param {string} options.start_date - Start date for events filter
+ * @param {string} options.end_date - End date for events filter
+ * @param {number} options.page - Page number for pagination
+ * @param {number} options.limit - Items per page
+ * @returns {Promise<Array>} Array of calendar events
+ */
+async function getAllEvents(tenantId, userId, options = {}) {
+  try {
+    const {
+      status = 'active',
+      filter = 'all',
+      search = '',
+      start_date,
+      end_date,
+      page = 1,
+      limit = 50,
+      sortBy = 'start_time',
+      sortDir = 'ASC'
+    } = options;
+
+    // Determine user's department and team for access control
+    const { role, departmentId, teamId } = await User.getUserDepartmentAndTeam(userId);
+    
+    // Build base query
+    let query = `
+      SELECT e.*, 
+             u.username as creator_name,
+             CASE WHEN a.id IS NOT NULL THEN a.response_status ELSE NULL END as user_response
+      FROM calendar_events e
+      LEFT JOIN users u ON e.created_by = u.id
+      LEFT JOIN calendar_attendees a ON e.id = a.event_id AND a.user_id = ?
+      WHERE e.tenant_id = ? AND e.status = ?
+    `;
+    
+    const queryParams = [userId, tenantId, status];
+    
+    // Apply org level filter
+    if (filter !== 'all') {
+      query += ' AND e.org_level = ?';
+      queryParams.push(filter);
+    }
+    
+    // Apply access control for non-admin users
+    if (role !== 'admin' && role !== 'root') {
+      query += ` AND (
+        e.org_level = 'company' OR 
+        (e.org_level = 'department' AND e.org_id = ?) OR
+        (e.org_level = 'team' AND e.org_id = ?) OR
+        EXISTS (SELECT 1 FROM calendar_attendees WHERE event_id = e.id AND user_id = ?)
+      )`;
+      queryParams.push(departmentId || 0, teamId || 0, userId);
+    }
+    
+    // Apply date range filter
+    if (start_date) {
+      query += ' AND e.end_time >= ?';
+      queryParams.push(start_date);
+    }
+    
+    if (end_date) {
+      query += ' AND e.start_time <= ?';
+      queryParams.push(end_date);
+    }
+    
+    // Apply search filter
+    if (search) {
+      query += ' AND (e.title LIKE ? OR e.description LIKE ? OR e.location LIKE ?)';
+      const searchTerm = `%${search}%`;
+      queryParams.push(searchTerm, searchTerm, searchTerm);
+    }
+    
+    // Apply sorting
+    query += ` ORDER BY e.${sortBy} ${sortDir}`;
+    
+    // Apply pagination
+    const offset = (page - 1) * limit;
+    query += ' LIMIT ? OFFSET ?';
+    queryParams.push(parseInt(limit, 10), offset);
+    
+    // Execute query
+    const [events] = await db.query(query, queryParams);
+    
+    console.log(`Found ${events.length} calendar events`);
+    
+    // Convert Buffer description to String if needed
+    events.forEach(event => {
+      if (event.description && Buffer.isBuffer(event.description)) {
+        console.log("Converting Buffer description to string");
+        event.description = event.description.toString('utf8');
+      } else if (event.description && typeof event.description === 'object' && 
+                event.description.type === 'Buffer' && Array.isArray(event.description.data)) {
+        console.log("Converting Buffer object to string");
+        event.description = Buffer.from(event.description.data).toString('utf8');
+      }
+    });
+    
+    // Count total events for pagination
+    let countQuery = `
+      SELECT COUNT(*) as total 
+      FROM calendar_events e
+      WHERE e.tenant_id = ? AND e.status = ?
+    `;
+    
+    const countParams = [tenantId, status];
+    
+    // Apply org level filter for count
+    if (filter !== 'all') {
+      countQuery += ' AND e.org_level = ?';
+      countParams.push(filter);
+    }
+    
+    // Apply access control for non-admin users for count
+    if (role !== 'admin' && role !== 'root') {
+      countQuery += ` AND (
+        e.org_level = 'company' OR 
+        (e.org_level = 'department' AND e.org_id = ?) OR
+        (e.org_level = 'team' AND e.org_id = ?) OR
+        EXISTS (SELECT 1 FROM calendar_attendees WHERE event_id = e.id AND user_id = ?)
+      )`;
+      countParams.push(departmentId || 0, teamId || 0, userId);
+    }
+    
+    // Apply date range filter for count
+    if (start_date) {
+      countQuery += ' AND e.end_time >= ?';
+      countParams.push(start_date);
+    }
+    
+    if (end_date) {
+      countQuery += ' AND e.start_time <= ?';
+      countParams.push(end_date);
+    }
+    
+    // Apply search filter for count
+    if (search) {
+      countQuery += ' AND (e.title LIKE ? OR e.description LIKE ? OR e.location LIKE ?)';
+      const searchTerm = `%${search}%`;
+      countParams.push(searchTerm, searchTerm, searchTerm);
+    }
+    
+    const [countResult] = await db.query(countQuery, countParams);
+    const totalEvents = countResult[0].total;
+    
+    return {
+      events,
+      pagination: {
+        total: totalEvents,
+        page: parseInt(page, 10),
+        limit: parseInt(limit, 10),
+        totalPages: Math.ceil(totalEvents / limit)
+      }
+    };
+  } catch (error) {
+    console.error('Error in getAllEvents:', error);
+    throw error;
+  }
+}
+
+/**
+ * Get a specific calendar event by ID
+ * @param {number} id - Event ID
+ * @param {number} tenantId - Tenant ID
+ * @param {number} userId - User ID checking the event
+ * @returns {Promise<Object>} Calendar event
+ */
+async function getEventById(id, tenantId, userId) {
+  try {
+    // Determine user's department and team for access control
+    const { role, departmentId, teamId } = await User.getUserDepartmentAndTeam(userId);
+    
+    // Query the event with user response status
+    const query = `
+      SELECT e.*, 
+             u.username as creator_name,
+             CASE WHEN a.id IS NOT NULL THEN a.response_status ELSE NULL END as user_response
+      FROM calendar_events e
+      LEFT JOIN users u ON e.created_by = u.id
+      LEFT JOIN calendar_attendees a ON e.id = a.event_id AND a.user_id = ?
+      WHERE e.id = ? AND e.tenant_id = ?
+    `;
+    
+    const [events] = await db.query(query, [userId, id, tenantId]);
+    
+    if (events.length === 0) {
+      return null;
+    }
+    
+    const event = events[0];
+    
+    // Convert Buffer description to String if needed
+    if (event.description && Buffer.isBuffer(event.description)) {
+      event.description = event.description.toString('utf8');
+    } else if (event.description && typeof event.description === 'object' && 
+              event.description.type === 'Buffer' && Array.isArray(event.description.data)) {
+      event.description = Buffer.from(event.description.data).toString('utf8');
+    }
+    
+    // Check access control for non-admin users
+    if (role !== 'admin' && role !== 'root') {
+      // Check if user is an attendee
+      const [attendeeRows] = await db.query(
+        'SELECT 1 FROM calendar_attendees WHERE event_id = ? AND user_id = ?',
+        [id, userId]
+      );
+      
+      const isAttendee = attendeeRows.length > 0;
+      
+      const hasAccess = 
+        event.org_level === 'company' || 
+        (event.org_level === 'department' && event.org_id === departmentId) ||
+        (event.org_level === 'team' && event.org_id === teamId) ||
+        isAttendee;
+      
+      if (!hasAccess) {
+        return null; // User doesn't have access to this event
+      }
+    }
+    
+    return event;
+  } catch (error) {
+    console.error('Error in getEventById:', error);
+    throw error;
+  }
+}
+
+/**
+ * Create a new calendar event
+ * @param {Object} eventData - Event data
+ * @returns {Promise<Object>} Created event
+ */
+async function createEvent(eventData) {
+  try {
+    const {
+      tenant_id,
+      title,
+      description,
+      location,
+      start_time,
+      end_time,
+      all_day,
+      org_level,
+      org_id,
+      created_by,
+      reminder_time,
+      color
+    } = eventData;
+    
+    // Validate required fields
+    if (!tenant_id || !title || !start_time || !end_time || !org_level || !org_id || !created_by) {
+      throw new Error('Missing required fields');
+    }
+    
+    // Ensure dates are valid
+    if (new Date(start_time) > new Date(end_time)) {
+      throw new Error('Start time must be before end time');
+    }
+    
+    // Insert new event
+    const query = `
+      INSERT INTO calendar_events 
+      (tenant_id, title, description, location, start_time, end_time, all_day, 
+       org_level, org_id, created_by, reminder_time, color)
+      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+    `;
+    
+    const [result] = await db.query(query, [
+      tenant_id,
+      title,
+      description || null,
+      location || null,
+      start_time,
+      end_time,
+      all_day ? 1 : 0,
+      org_level,
+      org_id,
+      created_by,
+      reminder_time || null,
+      color || '#3498db'
+    ]);
+    
+    // Get the created event
+    const createdEvent = await getEventById(result.insertId, tenant_id, created_by);
+    
+    // Add the creator as an attendee with 'accepted' status
+    if (createdEvent) {
+      await addEventAttendee(createdEvent.id, created_by, 'accepted');
+    }
+    
+    return createdEvent;
+  } catch (error) {
+    console.error('Error in createEvent:', error);
+    throw error;
+  }
+}
+
+/**
+ * Update a calendar event
+ * @param {number} id - Event ID
+ * @param {Object} eventData - Updated event data
+ * @param {number} tenantId - Tenant ID
+ * @returns {Promise<Object>} Updated event
+ */
+async function updateEvent(id, eventData, tenantId) {
+  try {
+    const {
+      title,
+      description,
+      location,
+      start_time,
+      end_time,
+      all_day,
+      org_level,
+      org_id,
+      status,
+      reminder_time,
+      color
+    } = eventData;
+    
+    // Build query dynamically based on provided fields
+    let query = 'UPDATE calendar_events SET updated_at = NOW()';
+    const queryParams = [];
+    
+    if (title !== undefined) {
+      query += ', title = ?';
+      queryParams.push(title);
+    }
+    
+    if (description !== undefined) {
+      query += ', description = ?';
+      queryParams.push(description);
+    }
+    
+    if (location !== undefined) {
+      query += ', location = ?';
+      queryParams.push(location);
+    }
+    
+    if (start_time !== undefined) {
+      query += ', start_time = ?';
+      queryParams.push(start_time);
+    }
+    
+    if (end_time !== undefined) {
+      query += ', end_time = ?';
+      queryParams.push(end_time);
+    }
+    
+    if (all_day !== undefined) {
+      query += ', all_day = ?';
+      queryParams.push(all_day ? 1 : 0);
+    }
+    
+    if (org_level !== undefined) {
+      query += ', org_level = ?';
+      queryParams.push(org_level);
+    }
+    
+    if (org_id !== undefined) {
+      query += ', org_id = ?';
+      queryParams.push(org_id);
+    }
+    
+    if (status !== undefined) {
+      query += ', status = ?';
+      queryParams.push(status);
+    }
+    
+    if (reminder_time !== undefined) {
+      query += ', reminder_time = ?';
+      queryParams.push(reminder_time);
+    }
+    
+    if (color !== undefined) {
+      query += ', color = ?';
+      queryParams.push(color);
+    }
+    
+    // Finish query
+    query += ' WHERE id = ? AND tenant_id = ?';
+    queryParams.push(id, tenantId);
+    
+    // Execute update
+    await db.query(query, queryParams);
+    
+    // Get the updated event
+    const updatedEvent = await getEventById(id, tenantId, eventData.created_by);
+    return updatedEvent;
+  } catch (error) {
+    console.error('Error in updateEvent:', error);
+    throw error;
+  }
+}
+
+/**
+ * Delete a calendar event
+ * @param {number} id - Event ID
+ * @param {number} tenantId - Tenant ID
+ * @returns {Promise<boolean>} Success status
+ */
+async function deleteEvent(id, tenantId) {
+  try {
+    // Delete event
+    const query = 'DELETE FROM calendar_events WHERE id = ? AND tenant_id = ?';
+    const [result] = await db.query(query, [id, tenantId]);
+    
+    return result.affectedRows > 0;
+  } catch (error) {
+    console.error('Error in deleteEvent:', error);
+    throw error;
+  }
+}
+
+/**
+ * Add an attendee to a calendar event
+ * @param {number} eventId - Event ID
+ * @param {number} userId - User ID
+ * @param {string} responseStatus - Response status (pending, accepted, declined, tentative)
+ * @returns {Promise<boolean>} Success status
+ */
+async function addEventAttendee(eventId, userId, responseStatus = 'pending') {
+  try {
+    // Check if already an attendee
+    const [attendees] = await db.query(
+      'SELECT * FROM calendar_attendees WHERE event_id = ? AND user_id = ?',
+      [eventId, userId]
+    );
+    
+    if (attendees.length > 0) {
+      // Update existing attendee status
+      await db.query(
+        'UPDATE calendar_attendees SET response_status = ?, responded_at = NOW() WHERE event_id = ? AND user_id = ?',
+        [responseStatus, eventId, userId]
+      );
+    } else {
+      // Add new attendee
+      await db.query(
+        'INSERT INTO calendar_attendees (event_id, user_id, response_status, responded_at) VALUES (?, ?, ?, NOW())',
+        [eventId, userId, responseStatus]
+      );
+    }
+    
+    return true;
+  } catch (error) {
+    console.error('Error in addEventAttendee:', error);
+    throw error;
+  }
+}
+
+/**
+ * Remove an attendee from a calendar event
+ * @param {number} eventId - Event ID
+ * @param {number} userId - User ID
+ * @returns {Promise<boolean>} Success status
+ */
+async function removeEventAttendee(eventId, userId) {
+  try {
+    // Remove attendee
+    const query = 'DELETE FROM calendar_attendees WHERE event_id = ? AND user_id = ?';
+    const [result] = await db.query(query, [eventId, userId]);
+    
+    return result.affectedRows > 0;
+  } catch (error) {
+    console.error('Error in removeEventAttendee:', error);
+    throw error;
+  }
+}
+
+/**
+ * User responds to a calendar event
+ * @param {number} eventId - Event ID
+ * @param {number} userId - User ID
+ * @param {string} response - Response (accepted, declined, tentative)
+ * @returns {Promise<boolean>} Success status
+ */
+async function respondToEvent(eventId, userId, response) {
+  try {
+    // Validate response
+    const validResponses = ['accepted', 'declined', 'tentative'];
+    if (!validResponses.includes(response)) {
+      throw new Error('Invalid response status');
+    }
+    
+    // Update response
+    return addEventAttendee(eventId, userId, response);
+  } catch (error) {
+    console.error('Error in respondToEvent:', error);
+    throw error;
+  }
+}
+
+/**
+ * Get attendees for a calendar event
+ * @param {number} eventId - Event ID
+ * @param {number} tenantId - Tenant ID
+ * @returns {Promise<Array>} Attendees with their response status
+ */
+async function getEventAttendees(eventId, tenantId) {
+  try {
+    const query = `
+      SELECT a.user_id, a.response_status, a.responded_at,
+             u.username, u.first_name, u.last_name, u.email, u.profile_picture
+      FROM calendar_attendees a
+      JOIN users u ON a.user_id = u.id
+      JOIN calendar_events e ON a.event_id = e.id
+      WHERE a.event_id = ? AND e.tenant_id = ?
+      ORDER BY u.first_name, u.last_name
+    `;
+    
+    const [attendees] = await db.query(query, [eventId, tenantId]);
+    return attendees;
+  } catch (error) {
+    console.error('Error in getEventAttendees:', error);
+    throw error;
+  }
+}
+
+/**
+ * Get upcoming events for a user's dashboard
+ * @param {number} tenantId - Tenant ID
+ * @param {number} userId - User ID
+ * @param {number} days - Number of days to look ahead
+ * @param {number} limit - Maximum number of events to return
+ * @returns {Promise<Array>} Array of upcoming calendar events
+ */
+async function getDashboardEvents(tenantId, userId, days = 7, limit = 5) {
+  try {
+    // Get user info for access control
+    const { role, departmentId, teamId } = await User.getUserDepartmentAndTeam(userId);
+    
+    // Calculate date range
+    const today = new Date();
+    const endDate = new Date();
+    endDate.setDate(today.getDate() + days);
+    
+    // Format dates for MySQL
+    const todayStr = today.toISOString().split('T')[0];
+    const endDateStr = endDate.toISOString().split('T')[0];
+    
+    // Build query for dashboard events
+    let query = `
+      SELECT e.*, 
+             u.username as creator_name,
+             CASE WHEN a.id IS NOT NULL THEN a.response_status ELSE NULL END as user_response
+      FROM calendar_events e
+      LEFT JOIN users u ON e.created_by = u.id
+      LEFT JOIN calendar_attendees a ON e.id = a.event_id AND a.user_id = ?
+      WHERE e.tenant_id = ? AND e.status = 'active'
+      AND e.start_time >= ? AND e.start_time <= ?
+    `;
+    
+    const queryParams = [userId, tenantId, todayStr, endDateStr];
+    
+    // Apply access control for non-admin users
+    if (role !== 'admin' && role !== 'root') {
+      query += ` AND (
+        e.org_level = 'company' OR 
+        (e.org_level = 'department' AND e.org_id = ?) OR
+        (e.org_level = 'team' AND e.org_id = ?) OR
+        EXISTS (SELECT 1 FROM calendar_attendees WHERE event_id = e.id AND user_id = ?)
+      )`;
+      queryParams.push(departmentId || 0, teamId || 0, userId);
+    }
+    
+    // Sort by start time, limited to the next few events
+    query += `
+      ORDER BY e.start_time ASC
+      LIMIT ?
+    `;
+    queryParams.push(parseInt(limit, 10));
+    
+    const [events] = await db.query(query, queryParams);
+    
+    // Convert Buffer description to String if needed
+    events.forEach(event => {
+      if (event.description && Buffer.isBuffer(event.description)) {
+        event.description = event.description.toString('utf8');
+      } else if (event.description && typeof event.description === 'object' && 
+                event.description.type === 'Buffer' && Array.isArray(event.description.data)) {
+        event.description = Buffer.from(event.description.data).toString('utf8');
+      }
+    });
+    
+    return events;
+  } catch (error) {
+    console.error('Error in getDashboardEvents:', error);
+    throw error;
+  }
+}
+
+/**
+ * Check if a user can manage an event
+ * @param {number} eventId - Event ID
+ * @param {number} userId - User ID
+ * @param {Object} userInfo - User info with role, departmentId, teamId
+ * @returns {Promise<boolean>} True if user can manage the event
+ */
+async function canManageEvent(eventId, userId, userInfo = null) {
+  try {
+    // Get event details
+    const [events] = await db.query(
+      'SELECT * FROM calendar_events WHERE id = ?',
+      [eventId]
+    );
+    
+    if (events.length === 0) {
+      return false;
+    }
+    
+    const event = events[0];
+    
+    // Get user info if not provided
+    const userRole = userInfo ? userInfo.role : null;
+    const userDeptId = userInfo ? userInfo.departmentId : null;
+    const userTeamId = userInfo ? userInfo.teamId : null;
+    
+    // If already have user info, use it
+    let role, departmentId, teamId;
+    
+    if (userRole && (userDeptId !== undefined) && (userTeamId !== undefined)) {
+      role = userRole;
+      departmentId = userDeptId;
+      teamId = userTeamId;
+    } else {
+      // Otherwise get it from the database
+      const userDetails = await User.getUserDepartmentAndTeam(userId);
+      role = userDetails.role;
+      departmentId = userDetails.departmentId;
+      teamId = userDetails.teamId;
+    }
+    
+    // Admins can manage all events
+    if (role === 'admin' || role === 'root') {
+      return true;
+    }
+    
+    // Event creator can manage their events
+    if (event.created_by === userId) {
+      return true;
+    }
+    
+    // Department managers can manage department events
+    if (role === 'manager' && event.org_level === 'department' && event.org_id === departmentId) {
+      return true;
+    }
+    
+    // Team leads can manage team events
+    if (role === 'team_lead' && event.org_level === 'team' && event.org_id === teamId) {
+      return true;
+    }
+    
+    return false;
+  } catch (error) {
+    console.error('Error in canManageEvent:', error);
+    throw error;
+  }
+}
+
+module.exports = {
+  getAllEvents,
+  getEventById,
+  createEvent,
+  updateEvent,
+  deleteEvent,
+  addEventAttendee,
+  removeEventAttendee,
+  respondToEvent,
+  getEventAttendees,
+  getDashboardEvents,
+  canManageEvent
+};
\ No newline at end of file
diff --git a/server/public/calendar.html b/server/public/calendar.html
new file mode 100644
index 0000000..b9a7e93
--- /dev/null
+++ b/server/public/calendar.html
@@ -0,0 +1,490 @@
+<!DOCTYPE html>
+<html lang="de">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>Firmenkalender - Assixx</title>
+  <!-- Dashboard Theme CSS -->
+  <link rel="stylesheet" href="/css/dashboard-theme.css">
+  <!-- Font Awesome -->
+  <link rel="stylesheet" href="/css/lib/fontawesome.min.css">
+  <!-- FullCalendar CSS -->
+  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css">
+  <!-- Calendar spezifische Styles -->
+  <link rel="stylesheet" href="/css/calendar.css">
+</head>
+<body>
+  <!-- Header -->
+  <header class="header">
+    <a href="/admin-dashboard.html" class="logo-container">
+      <img src="/images/logo.png" alt="Assixx Logo" class="logo">
+    </a>
+    <div class="header-actions">
+      <span id="user-info" class="text-secondary">Admin</span>
+      <button id="logout-btn" class="btn btn-secondary">Ausloggen</button>
+    </div>
+  </header>
+
+  <!-- Main Layout mit Sidebar -->
+  <div class="layout-container">
+    <!-- Sidebar Navigation -->
+    <aside class="sidebar">
+      <nav class="sidebar-nav">
+        <h3 class="sidebar-title">Navigation</h3>
+        <ul class="sidebar-menu">
+          <li class="sidebar-item">
+            <a href="/admin-dashboard.html" class="sidebar-link">
+              <span class="icon">
+                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
+                  <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
+                </svg>
+              </span>
+              <span>Dashboard</span>
+            </a>
+          </li>
+          <li class="sidebar-item">
+            <a href="/blackboard.html" class="sidebar-link">
+              <span class="icon">
+                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
+                  <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
+                </svg>
+              </span>
+              <span>Blackboard</span>
+            </a>
+          </li>
+          <li class="sidebar-item active">
+            <a href="/calendar.html" class="sidebar-link">
+              <span class="icon">
+                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
+                  <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V10h14v10zM9 14H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2zm-8 4H7v-2h2v2zm4 0h-2v-2h2v2zm4 0h-2v-2h2v2z"/>
+                </svg>
+              </span>
+              <span>Kalender</span>
+            </a>
+          </li>
+          <li class="sidebar-item">
+            <a href="/documents.html" class="sidebar-link">
+              <span class="icon">
+                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
+                  <path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/>
+                </svg>
+              </span>
+              <span>Dokumente</span>
+            </a>
+          </li>
+        </ul>
+      </nav>
+    </aside>
+
+    <!-- Main Content -->
+    <main class="container main-content">
+      <div class="flex flex-between mb-4">
+        <div>
+          <h1 class="card-title mb-2">Firmenkalender</h1>
+          <p class="text-secondary">Alle Termine und Veranstaltungen auf einen Blick</p>
+        </div>
+        <div class="flex gap-2">
+          <div class="btn-group view-selector">
+            <button id="monthView" class="btn btn-sm btn-primary active">Monat</button>
+            <button id="weekView" class="btn btn-sm btn-outline-primary">Woche</button>
+            <button id="dayView" class="btn btn-sm btn-outline-primary">Tag</button>
+            <button id="listView" class="btn btn-sm btn-outline-primary">Liste</button>
+          </div>
+          <button id="newEventBtn" class="btn btn-primary">
+            <i class="fas fa-plus"></i> Neuer Termin
+          </button>
+        </div>
+      </div>
+      
+      <!-- Filterleiste -->
+      <div class="card mb-4">
+        <div class="card-header">
+          <h3 class="card-title">Filter & Anzeige</h3>
+        </div>
+        <div class="card-body">
+          <div class="flex gap-4 flex-wrap">
+            <div class="form-group">
+              <label for="levelFilter" class="form-label">Ebene</label>
+              <div class="tab-navigation mb-2" id="levelFilter">
+                <button class="tab-btn active" data-value="all" id="filterAll">Alle</button>
+                <button class="tab-btn" data-value="company" id="filterCompany">Firma</button>
+                <button class="tab-btn" data-value="department" id="filterDepartment">Abteilung</button>
+                <button class="tab-btn" data-value="team" id="filterTeam">Team</button>
+              </div>
+            </div>
+            
+            <div class="form-group">
+              <label for="searchInput" class="form-label">Suche</label>
+              <div class="flex gap-1">
+                <input type="text" id="searchInput" class="form-input" placeholder="Suchbegriff...">
+                <button class="btn btn-primary" type="button" id="searchButton">
+                  <i class="fas fa-search"></i>
+                </button>
+              </div>
+            </div>
+            
+            <div class="flex-grow"></div>
+            
+            <div class="form-group">
+              <label class="form-label">Legende</label>
+              <div class="legend-container">
+                <div class="legend-item">
+                  <span class="legend-color" style="background-color: #3498db;"></span>
+                  <span class="legend-label">Firma</span>
+                </div>
+                <div class="legend-item">
+                  <span class="legend-color" style="background-color: #e67e22;"></span>
+                  <span class="legend-label">Abteilung</span>
+                </div>
+                <div class="legend-item">
+                  <span class="legend-color" style="background-color: #2ecc71;"></span>
+                  <span class="legend-label">Team</span>
+                </div>
+                <div class="legend-item">
+                  <span class="legend-color" style="background-color: #9b59b6;"></span>
+                  <span class="legend-label">Persönlich</span>
+                </div>
+              </div>
+            </div>
+          </div>
+        </div>
+      </div>
+      
+      <!-- Calendar Container -->
+      <div class="card calendar-card mb-4">
+        <div class="card-body p-0">
+          <div id="calendar"></div>
+        </div>
+      </div>
+      
+      <!-- Upcoming Events -->
+      <div class="card mb-4">
+        <div class="card-header">
+          <h3 class="card-title">Anstehende Termine</h3>
+        </div>
+        <div class="card-body">
+          <div id="upcomingEvents" class="upcoming-events">
+            <!-- Wird dynamisch befüllt -->
+            <div class="loading-placeholder">
+              <div class="loading-spinner"></div>
+              <p class="text-center mt-3">Termine werden geladen...</p>
+            </div>
+          </div>
+        </div>
+      </div>
+    </main>
+  </div> <!-- Ende des layout-container -->
+
+  <!-- Event Detail Modal -->
+  <div class="modal-overlay" id="eventDetailModal">
+    <div class="modal-container">
+      <div class="modal-header">
+        <h2 id="eventDetailModalLabel">Termin Details</h2>
+        <button type="button" class="modal-close" data-action="close">&times;</button>
+      </div>
+      <div class="modal-body">
+        <div id="eventDetailContent" class="fade-in">
+          <!-- Wird dynamisch gefüllt -->
+        </div>
+      </div>
+      <div class="modal-footer" id="eventDetailFooter">
+        <button type="button" class="btn btn-secondary" data-action="close">Schließen</button>
+        <!-- Weitere Buttons werden dynamisch hinzugefügt -->
+      </div>
+    </div>
+  </div>
+  
+  <!-- Event Form Modal -->
+  <div class="modal-overlay" id="eventFormModal">
+    <div class="modal-container modal-lg">
+      <div class="modal-header">
+        <h2 id="eventFormModalLabel">Neuer Termin</h2>
+        <button type="button" class="modal-close" data-action="close">&times;</button>
+      </div>
+      <div class="modal-body">
+        <form id="eventForm" class="simple-form">
+          <input type="hidden" id="eventId">
+          
+          <!-- Titel und Inhalt -->
+          <div class="form-group large-form-group">
+            <label for="eventTitle" class="big-label">Titel</label>
+            <input type="text" class="big-input" id="eventTitle" required>
+          </div>
+          
+          <div class="form-group large-form-group">
+            <label for="eventDescription" class="big-label">Beschreibung</label>
+            <textarea class="big-input" id="eventDescription" rows="4"></textarea>
+            <div class="simple-hint">Markdown-Formatierung möglich</div>
+          </div>
+          
+          <!-- Datum und Zeit -->
+          <div class="form-group large-form-group">
+            <div class="flex gap-4 flex-wrap">
+              <div class="flex-half">
+                <label for="eventStartDate" class="big-label">Startdatum</label>
+                <input type="date" class="big-input" id="eventStartDate" required>
+              </div>
+              <div class="flex-half">
+                <label for="eventStartTime" class="big-label">Startzeit</label>
+                <input type="time" class="big-input" id="eventStartTime" required>
+              </div>
+            </div>
+          </div>
+          
+          <div class="form-group large-form-group">
+            <div class="flex gap-4 flex-wrap">
+              <div class="flex-half">
+                <label for="eventEndDate" class="big-label">Enddatum</label>
+                <input type="date" class="big-input" id="eventEndDate" required>
+              </div>
+              <div class="flex-half">
+                <label for="eventEndTime" class="big-label">Endzeit</label>
+                <input type="time" class="big-input" id="eventEndTime" required>
+              </div>
+            </div>
+          </div>
+          
+          <div class="form-group large-form-group">
+            <div class="simple-checkbox">
+              <input type="checkbox" id="eventAllDay">
+              <label for="eventAllDay">
+                Ganztägiger Termin
+              </label>
+            </div>
+          </div>
+          
+          <!-- Ort -->
+          <div class="form-group large-form-group">
+            <label for="eventLocation" class="big-label">Ort</label>
+            <input type="text" class="big-input" id="eventLocation">
+          </div>
+          
+          <!-- Organisationseinheit -->
+          <div class="form-group large-form-group">
+            <label for="eventOrgLevel" class="big-label">Wer soll den Termin sehen?</label>
+            <select class="big-input" id="eventOrgLevel" required>
+              <option value="" disabled selected>-- Bitte wählen --</option>
+              <option value="company">Alle Mitarbeiter</option>
+              <option value="department">Bestimmte Abteilung</option>
+              <option value="team">Bestimmtes Team</option>
+            </select>
+          </div>
+          
+          <div class="form-group large-form-group">
+            <label for="eventOrgId" class="big-label">Welche Abteilung/Team?</label>
+            <select class="big-input" id="eventOrgId" required disabled>
+              <option value="" disabled selected>-- Bitte erst oben auswählen --</option>
+            </select>
+          </div>
+          
+          <!-- Farbe und Erinnerung -->
+          <div class="form-group large-form-group">
+            <label for="eventColor" class="big-label">Farbe</label>
+            <div class="color-picker">
+              <div class="color-option" data-color="#3498db" style="background-color: #3498db;"></div>
+              <div class="color-option" data-color="#2ecc71" style="background-color: #2ecc71;"></div>
+              <div class="color-option" data-color="#e67e22" style="background-color: #e67e22;"></div>
+              <div class="color-option" data-color="#9b59b6" style="background-color: #9b59b6;"></div>
+              <div class="color-option" data-color="#e74c3c" style="background-color: #e74c3c;"></div>
+              <div class="color-option" data-color="#f1c40f" style="background-color: #f1c40f;"></div>
+              <div class="color-option" data-color="#1abc9c" style="background-color: #1abc9c;"></div>
+              <div class="color-option" data-color="#34495e" style="background-color: #34495e;"></div>
+            </div>
+            <input type="hidden" id="eventColor" value="#3498db">
+          </div>
+          
+          <div class="form-group large-form-group">
+            <label for="eventReminderTime" class="big-label">Erinnerung</label>
+            <select class="big-input" id="eventReminderTime">
+              <option value="">Keine Erinnerung</option>
+              <option value="5">5 Minuten vorher</option>
+              <option value="15">15 Minuten vorher</option>
+              <option value="30">30 Minuten vorher</option>
+              <option value="60">1 Stunde vorher</option>
+              <option value="120">2 Stunden vorher</option>
+              <option value="1440">1 Tag vorher</option>
+            </select>
+          </div>
+          
+          <!-- Teilnehmer -->
+          <div class="form-group large-form-group">
+            <label class="big-label">Teilnehmer</label>
+            <div class="attendees-container" id="attendeesContainer">
+              <!-- Wird dynamisch befüllt -->
+            </div>
+            <button type="button" class="btn btn-outline-primary mt-2" id="addAttendeeBtn">
+              <i class="fas fa-plus"></i> Teilnehmer hinzufügen
+            </button>
+          </div>
+        </form>
+      </div>
+      <div class="modal-footer">
+        <button type="button" class="big-button secondary-button" data-action="close">
+          Abbrechen
+        </button>
+        <button type="button" class="big-button primary-button" id="saveEventBtn">
+          Speichern
+        </button>
+      </div>
+    </div>
+  </div>
+  
+  <!-- Attendees Modal -->
+  <div class="modal-overlay" id="attendeesModal">
+    <div class="modal-container">
+      <div class="modal-header">
+        <h2 id="attendeesModalLabel">Teilnehmer hinzufügen</h2>
+        <button type="button" class="modal-close" data-action="close">&times;</button>
+      </div>
+      <div class="modal-body">
+        <div class="form-group mb-3">
+          <input type="text" class="form-input" id="attendeeSearch" placeholder="Mitarbeiter suchen...">
+        </div>
+        <div class="attendees-list" id="attendeesList">
+          <!-- Wird dynamisch befüllt -->
+          <div class="loading-placeholder">
+            <div class="loading-spinner"></div>
+            <p class="text-center mt-3">Mitarbeiter werden geladen...</p>
+          </div>
+        </div>
+      </div>
+      <div class="modal-footer">
+        <button type="button" class="btn btn-secondary" data-action="close">Abbrechen</button>
+        <button type="button" class="btn btn-primary" id="addSelectedAttendeesBtn">Hinzufügen</button>
+      </div>
+    </div>
+  </div>
+  
+  <!-- Event Response Modal -->
+  <div class="modal-overlay" id="eventResponseModal">
+    <div class="modal-container modal-sm">
+      <div class="modal-header">
+        <h2 id="eventResponseModalLabel">Auf Einladung antworten</h2>
+        <button type="button" class="modal-close" data-action="close">&times;</button>
+      </div>
+      <div class="modal-body">
+        <p id="responseEventTitle" class="mb-4">Titel des Termins</p>
+        <div class="response-options">
+          <button type="button" class="response-btn" data-response="accepted">
+            <i class="fas fa-check"></i>
+            <span>Zusagen</span>
+          </button>
+          <button type="button" class="response-btn" data-response="tentative">
+            <i class="fas fa-question"></i>
+            <span>Vielleicht</span>
+          </button>
+          <button type="button" class="response-btn" data-response="declined">
+            <i class="fas fa-times"></i>
+            <span>Absagen</span>
+          </button>
+        </div>
+      </div>
+      <div class="modal-footer">
+        <button type="button" class="btn btn-secondary" data-action="close">Schließen</button>
+      </div>
+    </div>
+  </div>
+  
+  <!-- Confirmation Modal -->
+  <div class="modal-overlay" id="confirmationModal">
+    <div class="modal-container modal-sm">
+      <div class="modal-header">
+        <h2 id="confirmationModalLabel">Bestätigung</h2>
+        <button type="button" class="modal-close" data-action="close">&times;</button>
+      </div>
+      <div class="modal-body">
+        <p id="confirmationMessage" class="mb-0">Möchten Sie diesen Termin wirklich löschen?</p>
+      </div>
+      <div class="modal-footer">
+        <button type="button" class="btn btn-secondary" data-action="close">Abbrechen</button>
+        <button type="button" class="btn btn-danger" id="confirmActionBtn">Löschen</button>
+      </div>
+    </div>
+  </div>
+
+  <!-- Marked.js for Markdown rendering -->
+  <script src="/js/lib/marked.min.js"></script>
+  <!-- FullCalendar -->
+  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js"></script>
+  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/locales-all.min.js"></script>
+  <!-- Standalone scripts for Calendar -->
+  <script>
+    // Definiere DashboardUI direkt hier, um Abhängigkeiten zu vermeiden
+    window.DashboardUI = {
+      openModal: function(modalId) {
+        const modal = document.getElementById(modalId);
+        if (modal) {
+          modal.style.opacity = '1';
+          modal.style.visibility = 'visible';
+          modal.classList.add('active');
+        }
+      },
+      closeModal: function(modalId) {
+        const modal = document.getElementById(modalId);
+        if (modal) {
+          modal.style.opacity = '0';
+          modal.style.visibility = 'hidden';
+          modal.classList.remove('active');
+        }
+      },
+      showToast: function(message, type) {
+        // Einfache Toast-Implementierung
+        const toast = document.createElement('div');
+        toast.className = 'toast-' + (type || 'info');
+        toast.textContent = message;
+        
+        // Toast-Container erstellen
+        let container = document.querySelector('.toast-container');
+        if (!container) {
+          container = document.createElement('div');
+          container.className = 'toast-container';
+          document.body.appendChild(container);
+        }
+        
+        container.appendChild(toast);
+        
+        // Nach 3 Sekunden ausblenden
+        setTimeout(function() {
+          toast.remove();
+        }, 3000);
+      },
+      formatDate: function(date) {
+        if (!date) return '-';
+        const d = new Date(date);
+        return d.toLocaleDateString('de-DE');
+      }
+    };
+  </script>
+  <style>
+    /* Toast-Styles direkt im HTML einbinden */
+    .toast-container {
+      position: fixed;
+      bottom: 16px;
+      right: 16px;
+      z-index: 9999;
+    }
+    .toast-info, .toast-error, .toast-success {
+      background-color: var(--background-light);
+      color: var(--text-primary);
+      border-left: 4px solid var(--primary-color);
+      padding: 12px 16px;
+      margin-top: 8px;
+      border-radius: var(--radius-md);
+      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
+      font-size: 14px;
+    }
+    .toast-error {
+      border-left-color: var(--error-color);
+    }
+    .toast-success {
+      border-left-color: var(--success-color);
+    }
+    /* Zusätzliche Styles für fehlende Klassen */
+    .d-none {
+      display: none !important;
+    }
+  </style>
+  <!-- Calendar Scripts -->
+  <script src="/js/calendar.js"></script>
+</body>
+</html>
\ No newline at end of file
diff --git a/server/public/css/calendar.css b/server/public/css/calendar.css
new file mode 100644
index 0000000..865c1d9
--- /dev/null
+++ b/server/public/css/calendar.css
@@ -0,0 +1,640 @@
+/**
+ * Calendar System Styles - Angepasst an das Assixx-Dashboard-Design
+ */
+
+/* Main content padding */
+.main-content {
+  padding: var(--spacing-lg);
+  width: 100%;
+  overflow-y: auto;
+  height: calc(100vh - 56px);
+}
+
+/* Calendar Container */
+.calendar-card {
+  border: 1px solid var(--border-color);
+  border-radius: var(--radius-md);
+  box-shadow: var(--shadow-md);
+}
+
+#calendar {
+  width: 100%;
+  background-color: var(--background-light);
+  padding: 10px;
+}
+
+/* Calendar Header */
+.fc-header-toolbar {
+  margin-bottom: 1.5em !important;
+  padding: 0.5em 1em;
+}
+
+.fc-toolbar-title {
+  font-size: 1.5em !important;
+  font-weight: 500;
+  color: var(--text-primary);
+}
+
+/* Calendar Buttons - Angepasst an Assixx Design */
+.fc-button-primary {
+  background-color: var(--primary-color) !important;
+  border-color: var(--primary-color) !important;
+  box-shadow: var(--shadow-sm);
+}
+
+.fc-button-primary:hover {
+  background-color: var(--primary-dark) !important;
+  border-color: var(--primary-dark) !important;
+}
+
+.fc-button-active {
+  background-color: var(--primary-dark) !important;
+  border-color: var(--primary-dark) !important;
+}
+
+/* Calendar body */
+.fc-daygrid-day-frame {
+  color: var(--text-primary);
+  background-color: transparent;
+}
+
+.fc-day-today {
+  background-color: rgba(var(--primary-rgb), 0.1) !important;
+}
+
+.fc-daygrid-day-number,
+.fc-col-header-cell a {
+  color: var(--text-primary);
+  text-decoration: none;
+}
+
+/* Event styling */
+.fc-event {
+  border-radius: var(--radius-sm);
+  cursor: pointer;
+  border: none !important;
+  box-shadow: var(--shadow-sm);
+  transition: transform 0.2s, box-shadow 0.2s;
+}
+
+.fc-event:hover {
+  transform: translateY(-2px);
+  box-shadow: var(--shadow-md);
+}
+
+.fc-event-title {
+  font-weight: 500 !important;
+  font-size: 0.85em !important;
+  padding: 1px 2px;
+}
+
+.fc-event-time {
+  font-size: 0.8em !important;
+  font-weight: normal !important;
+  opacity: 0.8;
+}
+
+/* Event colors based on org level */
+.event-company {
+  background-color: #3498db !important;
+  border-color: #3498db !important;
+}
+
+.event-department {
+  background-color: #e67e22 !important;
+  border-color: #e67e22 !important;
+}
+
+.event-team {
+  background-color: #2ecc71 !important;
+  border-color: #2ecc71 !important;
+}
+
+.event-personal {
+  background-color: #9b59b6 !important;
+  border-color: #9b59b6 !important;
+}
+
+/* View Selector Styling */
+.view-selector {
+  margin-right: 10px;
+}
+
+.view-selector button {
+  border-radius: 0;
+}
+
+.view-selector button:first-child {
+  border-top-left-radius: var(--radius-sm);
+  border-bottom-left-radius: var(--radius-sm);
+}
+
+.view-selector button:last-child {
+  border-top-right-radius: var(--radius-sm);
+  border-bottom-right-radius: var(--radius-sm);
+}
+
+/* Upcoming Events Section */
+.upcoming-events {
+  max-height: 300px;
+  overflow-y: auto;
+}
+
+.event-item {
+  display: flex;
+  padding: 12px;
+  border-bottom: 1px solid var(--border-color);
+  transition: background-color 0.2s;
+}
+
+.event-item:last-child {
+  border-bottom: none;
+}
+
+.event-item:hover {
+  background-color: rgba(var(--primary-rgb), 0.05);
+}
+
+.event-date {
+  flex: 0 0 90px;
+  text-align: center;
+  padding: 10px;
+  background-color: var(--background-dark);
+  border-radius: var(--radius-sm);
+  margin-right: 15px;
+  display: flex;
+  flex-direction: column;
+  justify-content: center;
+}
+
+.event-day {
+  font-size: 1.5rem;
+  font-weight: 700;
+  color: var(--primary-color);
+  line-height: 1;
+}
+
+.event-month {
+  font-size: 0.8rem;
+  text-transform: uppercase;
+  color: var(--text-secondary);
+}
+
+.event-time {
+  font-size: 0.8rem;
+  margin-top: 5px;
+  color: var(--text-secondary);
+}
+
+.event-details {
+  flex: 1;
+}
+
+.event-title {
+  font-weight: 600;
+  font-size: 1rem;
+  margin-bottom: 5px;
+  color: var(--text-primary);
+}
+
+.event-location {
+  font-size: 0.85rem;
+  color: var(--text-secondary);
+  display: flex;
+  align-items: center;
+}
+
+.event-location i {
+  margin-right: 5px;
+}
+
+.event-level {
+  display: inline-block;
+  padding: 2px 8px;
+  border-radius: var(--radius-sm);
+  font-size: 0.7rem;
+  color: white;
+  margin-top: 5px;
+}
+
+.event-level-company {
+  background-color: #3498db;
+}
+
+.event-level-department {
+  background-color: #e67e22;
+}
+
+.event-level-team {
+  background-color: #2ecc71;
+}
+
+.event-level-personal {
+  background-color: #9b59b6;
+}
+
+/* Loading Spinner */
+.loading-spinner {
+  width: 40px;
+  height: 40px;
+  border: 3px solid var(--primary-color);
+  border-top-color: transparent;
+  border-radius: 50%;
+  display: inline-block;
+  margin: var(--spacing-md) auto;
+  animation: spin 1s linear infinite;
+}
+
+@keyframes spin {
+  to { transform: rotate(360deg); }
+}
+
+/* Color Picker */
+.color-picker {
+  display: flex;
+  gap: 10px;
+  flex-wrap: wrap;
+  margin-top: 10px;
+}
+
+.color-option {
+  width: 30px;
+  height: 30px;
+  border-radius: 50%;
+  cursor: pointer;
+  transition: transform 0.2s, box-shadow 0.2s;
+}
+
+.color-option:hover {
+  transform: scale(1.1);
+  box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.3);
+}
+
+.color-option.selected {
+  box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.8);
+}
+
+/* Modal Overlay */
+.modal-overlay {
+  position: fixed;
+  top: 0;
+  left: 0;
+  right: 0;
+  bottom: 0;
+  background-color: rgba(0, 0, 0, 0.7);
+  display: flex;
+  align-items: center;
+  justify-content: center;
+  z-index: 2000;
+  opacity: 0;
+  visibility: hidden;
+  transition: opacity 0.3s ease, visibility 0.3s ease;
+}
+
+.modal-overlay.active {
+  opacity: 1;
+  visibility: visible;
+}
+
+.modal-container {
+  background-color: var(--background-light);
+  border-radius: var(--radius-md);
+  width: 90%;
+  max-width: 800px;
+  max-height: 90vh;
+  display: flex;
+  flex-direction: column;
+  box-shadow: var(--shadow-lg);
+  border: 1px solid var(--border-color);
+  overflow: hidden;
+  transform: translateY(20px);
+  transition: transform 0.3s ease;
+}
+
+.modal-overlay.active .modal-container {
+  transform: translateY(0);
+}
+
+.modal-sm {
+  max-width: 500px;
+}
+
+.modal-lg {
+  max-width: 900px;
+}
+
+.modal-header {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  padding: var(--spacing-md);
+  border-bottom: 1px solid var(--border-color);
+}
+
+.modal-header h2 {
+  color: var(--primary-color);
+  font-size: 20px;
+  margin: 0;
+}
+
+.modal-close {
+  background: none;
+  border: none;
+  color: var(--text-secondary);
+  font-size: 24px;
+  cursor: pointer;
+  transition: color 0.3s ease;
+}
+
+.modal-close:hover {
+  color: var(--primary-color);
+}
+
+.modal-body {
+  padding: var(--spacing-lg);
+  overflow-y: auto;
+  max-height: 70vh;
+}
+
+.modal-footer {
+  padding: var(--spacing-md);
+  border-top: 1px solid var(--border-color);
+  display: flex;
+  justify-content: flex-end;
+  gap: var(--spacing-md);
+  background-color: rgba(0, 0, 0, 0.1);
+}
+
+/* Detail modal - angepasst an Assixx Design */
+.event-detail-header {
+  border-bottom: 1px solid var(--border-color, #ddd);
+  padding-bottom: 1rem;
+  margin-bottom: 1.5rem;
+}
+
+.event-detail-meta {
+  display: flex;
+  align-items: center;
+  margin-top: 0.5rem;
+  color: var(--text-secondary, #757575);
+  font-size: 0.875rem;
+}
+
+.event-detail-content {
+  margin-bottom: 1.5rem;
+  line-height: 1.6;
+  color: var(--text-primary, #212121);
+}
+
+/* Legend for color codes */
+.legend-container {
+  display: flex;
+  flex-wrap: wrap;
+  gap: 15px;
+  margin-top: 5px;
+}
+
+.legend-item {
+  display: flex;
+  align-items: center;
+  font-size: 0.85rem;
+}
+
+.legend-color {
+  width: 14px;
+  height: 14px;
+  border-radius: 3px;
+  margin-right: 5px;
+}
+
+/* Attendees list */
+.attendees-container {
+  max-height: 150px;
+  overflow-y: auto;
+  border: 1px solid var(--border-color);
+  border-radius: var(--radius-sm);
+  padding: 10px;
+  margin-bottom: 10px;
+}
+
+.attendee-item {
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  padding: 6px 10px;
+  border-bottom: 1px solid var(--border-color);
+  background-color: var(--background-dark);
+  border-radius: var(--radius-sm);
+  margin-bottom: 5px;
+}
+
+.attendee-item:last-child {
+  margin-bottom: 0;
+}
+
+.attendee-name {
+  flex: 1;
+}
+
+.attendee-status {
+  font-size: 0.8rem;
+  padding: 2px 8px;
+  border-radius: var(--radius-sm);
+  margin-right: 10px;
+}
+
+.status-pending {
+  background-color: var(--text-secondary);
+  color: white;
+}
+
+.status-accepted {
+  background-color: var(--success-color);
+  color: white;
+}
+
+.status-declined {
+  background-color: var(--error-color);
+  color: white;
+}
+
+.status-tentative {
+  background-color: var(--warning-color);
+  color: white;
+}
+
+.remove-attendee {
+  background: none;
+  border: none;
+  color: var(--error-color);
+  cursor: pointer;
+  font-size: 1rem;
+}
+
+/* Response buttons */
+.response-options {
+  display: flex;
+  justify-content: space-around;
+  margin: 20px 0;
+}
+
+.response-btn {
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  background: none;
+  border: 2px solid var(--border-color);
+  border-radius: var(--radius-md);
+  padding: 15px;
+  cursor: pointer;
+  transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
+  width: 100px;
+}
+
+.response-btn i {
+  font-size: 24px;
+  margin-bottom: 8px;
+}
+
+.response-btn:hover {
+  transform: translateY(-3px);
+  box-shadow: var(--shadow-md);
+}
+
+.response-btn[data-response="accepted"] {
+  color: var(--success-color);
+}
+
+.response-btn[data-response="accepted"]:hover {
+  border-color: var(--success-color);
+}
+
+.response-btn[data-response="tentative"] {
+  color: var(--warning-color);
+}
+
+.response-btn[data-response="tentative"]:hover {
+  border-color: var(--warning-color);
+}
+
+.response-btn[data-response="declined"] {
+  color: var(--error-color);
+}
+
+.response-btn[data-response="declined"]:hover {
+  border-color: var(--error-color);
+}
+
+/* Form layout helpers */
+.flex-half {
+  flex: 0 0 calc(50% - 10px);
+}
+
+.flex-grow {
+  flex: 1;
+}
+
+/* Einfaches, übersichtliches Formular-Styling */
+.simple-form {
+  padding: 10px;
+}
+
+.large-form-group {
+  margin-bottom: 25px;
+  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
+  padding-bottom: 20px;
+}
+
+.big-label {
+  display: block;
+  font-size: 18px;
+  font-weight: 500;
+  margin-bottom: 12px;
+  color: var(--text-primary);
+}
+
+.big-input {
+  display: block;
+  width: 100%;
+  padding: 12px 15px;
+  background-color: var(--background-dark);
+  border: 2px solid var(--border-color);
+  border-radius: var(--radius-md);
+  color: var(--text-primary);
+  font-size: 16px;
+  transition: border-color 0.2s;
+}
+
+.big-input:focus {
+  border-color: var(--primary-color);
+  outline: none;
+}
+
+.simple-hint {
+  font-size: 14px;
+  color: var(--text-secondary);
+  margin-top: 8px;
+}
+
+/* Einfache Checkbox */
+.simple-checkbox {
+  margin: 10px 0;
+}
+
+.simple-checkbox input[type="checkbox"] {
+  margin-right: 10px;
+  transform: scale(1.3);
+}
+
+.simple-checkbox label {
+  font-size: 16px;
+  cursor: pointer;
+}
+
+/* Große, klare Buttons */
+.big-button {
+  padding: 12px 25px;
+  font-size: 16px;
+  border-radius: var(--radius-md);
+  border: none;
+  cursor: pointer;
+  font-weight: 500;
+  transition: background-color 0.2s;
+}
+
+.primary-button {
+  background-color: var(--primary-color);
+  color: white;
+}
+
+.primary-button:hover {
+  background-color: var(--primary-dark);
+}
+
+.secondary-button {
+  background-color: rgba(255, 255, 255, 0.1);
+  color: var(--text-primary);
+}
+
+.secondary-button:hover {
+  background-color: rgba(255, 255, 255, 0.15);
+}
+
+/* Responsive adjustments */
+@media (max-width: 767.98px) {
+  .flex-half {
+    flex: 0 0 100%;
+  }
+  
+  .event-date {
+    flex: 0 0 70px;
+  }
+  
+  .fc-toolbar {
+    flex-direction: column;
+  }
+  
+  .fc-toolbar-chunk {
+    margin-bottom: 10px;
+  }
+}
\ No newline at end of file
diff --git a/server/public/js/calendar.js b/server/public/js/calendar.js
new file mode 100644
index 0000000..3a5cdc3
--- /dev/null
+++ b/server/public/js/calendar.js
@@ -0,0 +1,1505 @@
+/**
+ * Calendar System
+ * Client-side JavaScript for the company calendar feature
+ */
+
+// Global variables
+let calendar;
+let currentFilter = 'all';
+let currentSearch = '';
+let departments = [];
+let teams = [];
+let employees = [];
+let isAdmin = false;
+let currentUserId = null;
+let currentUserRole = null;
+let currentDepartmentId = null;
+let currentTeamId = null;
+let selectedAttendees = [];
+let calendarView = 'dayGridMonth'; // Default view
+
+// Initialize when document is ready
+document.addEventListener('DOMContentLoaded', function() {
+  console.log("Calendar initializing...");
+  
+  // Alle Schließen-Buttons einrichten
+  setupCloseButtons();
+  
+  // Check if user is logged in
+  checkLoggedIn().then(() => {
+    // Load user data
+    fetchUserData().then(userData => {
+      console.log("User data loaded:", userData);
+      currentUserId = userData.id;
+      currentUserRole = userData.role;
+      currentDepartmentId = userData.departmentId || userData.department_id;
+      currentTeamId = userData.teamId || userData.team_id;
+      isAdmin = userData.role === 'admin' || userData.role === 'root';
+      
+      // Show/hide "New Event" button based on permissions
+      const newEventBtn = document.getElementById('newEventBtn');
+      if (newEventBtn) {
+        newEventBtn.style.display = isAdmin ? 'block' : 'none';
+      }
+      console.log(`User role: ${currentUserRole}, isAdmin: ${isAdmin}`);
+      
+      // Load departments and teams for form dropdowns
+      loadDepartmentsAndTeams();
+      
+      // Initialize calendar
+      initializeCalendar();
+      
+      // Load upcoming events
+      loadUpcomingEvents();
+    }).catch(error => {
+      console.error("Error loading user data:", error);
+      window.location.href = "/login.html";
+    });
+    
+    // Setup event listeners
+    setupEventListeners();
+  }).catch(error => {
+    console.error("Error checking login:", error);
+    window.location.href = "/login.html";
+  });
+});
+
+/**
+ * Setup close buttons for all modals
+ */
+function setupCloseButtons() {
+  console.log("Setting up close buttons for modals");
+  
+  // Füge Event-Listener zu allen Elementen mit data-action="close" hinzu
+  document.querySelectorAll('[data-action="close"]').forEach(button => {
+    button.addEventListener('click', function() {
+      console.log("Close button clicked");
+      // Finde das übergeordnete Modal
+      const modal = this.closest('.modal-overlay');
+      if (modal) {
+        console.log("Closing modal:", modal.id);
+        window.DashboardUI.closeModal(modal.id);
+      } else {
+        console.error("No parent modal found for close button");
+      }
+    });
+  });
+  
+  // Schließen beim Klicken außerhalb des Modal-Inhalts
+  document.querySelectorAll('.modal-overlay').forEach(modal => {
+    modal.addEventListener('click', function(event) {
+      // Nur schließen, wenn der Klick auf den Modal-Hintergrund erfolgt (nicht auf den Inhalt)
+      if (event.target === modal) {
+        console.log("Clicked outside modal content, closing modal:", modal.id);
+        window.DashboardUI.closeModal(modal.id);
+      }
+    });
+  });
+  
+  console.log("Close buttons setup completed");
+}
+
+/**
+ * Initialize FullCalendar
+ */
+function initializeCalendar() {
+  const calendarEl = document.getElementById('calendar');
+  
+  if (!calendarEl) {
+    console.error('Calendar element not found');
+    return;
+  }
+  
+  calendar = new FullCalendar.Calendar(calendarEl, {
+    initialView: calendarView,
+    locale: 'de',
+    headerToolbar: {
+      left: 'prev,next today',
+      center: 'title',
+      right: ''
+    },
+    buttonText: {
+      today: 'Heute',
+      month: 'Monat',
+      week: 'Woche',
+      day: 'Tag',
+      list: 'Liste'
+    },
+    allDayText: 'Ganztägig',
+    firstDay: 1, // Monday as first day
+    slotMinTime: '07:00:00',
+    slotMaxTime: '20:00:00',
+    height: 'auto',
+    nowIndicator: true,
+    dayMaxEvents: true,
+    navLinks: true,
+    selectable: isAdmin, // Only admins can select dates to create events
+    select: function(info) {
+      if (isAdmin) {
+        openEventForm(null, info.start, info.end, info.allDay);
+      }
+    },
+    eventClick: function(info) {
+      viewEvent(info.event.id);
+    },
+    eventClassNames: function(info) {
+      // Add class based on event's org_level
+      const orgLevel = info.event.extendedProps.org_level;
+      if (orgLevel) {
+        return [`event-${orgLevel}`];
+      }
+      return [];
+    },
+    events: fetchEvents,
+    eventTimeFormat: {
+      hour: '2-digit',
+      minute: '2-digit',
+      meridiem: false
+    },
+    dayHeaderFormat: { weekday: 'short', day: 'numeric', month: 'numeric' },
+    eventDidMount: function(info) {
+      // Add tooltip with full title
+      tippy(info.el, {
+        content: info.event.title,
+        placement: 'top',
+        arrow: true
+      });
+    }
+  });
+  
+  calendar.render();
+}
+
+/**
+ * Fetch events for calendar
+ */
+async function fetchEvents(info, successCallback, failureCallback) {
+  try {
+    console.log(`Fetching events from ${info.start.toISOString()} to ${info.end.toISOString()}`);
+    
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    const start_date = info.start.toISOString().split('T')[0];
+    const end_date = info.end.toISOString().split('T')[0];
+    
+    // Build query URL with filter and search parameters
+    let url = `/api/calendar?start_date=${start_date}&end_date=${end_date}`;
+    
+    if (currentFilter !== 'all') {
+      url += `&filter=${currentFilter}`;
+    }
+    
+    if (currentSearch) {
+      url += `&search=${encodeURIComponent(currentSearch)}`;
+    }
+    
+    // Fetch events with authentication token
+    const response = await fetch(url, {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      if (response.status === 401) {
+        // Redirect to login if unauthorized
+        window.location.href = '/login.html';
+        throw new Error('Unauthorized');
+      }
+      throw new Error('Failed to load events');
+    }
+    
+    const data = await response.json();
+    const events = data.events.map(event => formatEvent(event));
+    
+    // Call success callback with events
+    successCallback(events);
+  } catch (error) {
+    console.error('Error loading events:', error);
+    failureCallback(error);
+    showToast('error', 'Fehler beim Laden der Termine.');
+  }
+}
+
+/**
+ * Format event data for FullCalendar
+ */
+function formatEvent(event) {
+  // Define color based on org_level
+  let color;
+  switch (event.org_level) {
+    case 'company':
+      color = '#3498db';
+      break;
+    case 'department':
+      color = '#e67e22';
+      break;
+    case 'team':
+      color = '#2ecc71';
+      break;
+    default:
+      color = event.color || '#9b59b6';
+  }
+  
+  return {
+    id: event.id,
+    title: event.title,
+    start: event.start_time,
+    end: event.end_time,
+    allDay: event.all_day === 1,
+    color: color,
+    borderColor: color,
+    extendedProps: {
+      description: event.description,
+      location: event.location,
+      org_level: event.org_level,
+      org_id: event.org_id,
+      created_by: event.created_by,
+      creator_name: event.creator_name,
+      reminder_time: event.reminder_time,
+      user_response: event.user_response
+    }
+  };
+}
+
+/**
+ * Load upcoming events for sidebar
+ */
+async function loadUpcomingEvents() {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    // Fetch upcoming events
+    const response = await fetch('/api/calendar/dashboard', {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      throw new Error('Failed to load upcoming events');
+    }
+    
+    const events = await response.json();
+    displayUpcomingEvents(events);
+  } catch (error) {
+    console.error('Error loading upcoming events:', error);
+    const upcomingEvents = document.getElementById('upcomingEvents');
+    upcomingEvents.innerHTML = '<p class="text-center">Fehler beim Laden der Termine.</p>';
+  }
+}
+
+/**
+ * Display upcoming events in the sidebar
+ */
+function displayUpcomingEvents(events) {
+  const container = document.getElementById('upcomingEvents');
+  
+  if (!container) {
+    console.error('Upcoming events container not found');
+    return;
+  }
+  
+  container.innerHTML = '';
+  
+  if (!events || events.length === 0) {
+    container.innerHTML = '<p class="text-center">Keine anstehenden Termine gefunden.</p>';
+    return;
+  }
+  
+  events.forEach(event => {
+    // Parse dates
+    const startDate = new Date(event.start_time);
+    const endDate = new Date(event.end_time);
+    
+    // Format date components
+    const day = startDate.getDate();
+    const month = startDate.toLocaleDateString('de-DE', { month: 'short' });
+    
+    // Format time (only if not all day)
+    let timeStr = event.all_day ? 'Ganztägig' : 
+      `${startDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} - ${endDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}`;
+    
+    // Determine level badge class
+    let levelClass = 'event-level-personal';
+    let levelText = 'Persönlich';
+    
+    if (event.org_level === 'company') {
+      levelClass = 'event-level-company';
+      levelText = 'Firma';
+    } else if (event.org_level === 'department') {
+      levelClass = 'event-level-department';
+      levelText = 'Abteilung';
+    } else if (event.org_level === 'team') {
+      levelClass = 'event-level-team';
+      levelText = 'Team';
+    }
+    
+    const eventItem = document.createElement('div');
+    eventItem.className = 'event-item';
+    eventItem.setAttribute('data-id', event.id);
+    
+    eventItem.innerHTML = `
+      <div class="event-date">
+        <span class="event-day">${day}</span>
+        <span class="event-month">${month}</span>
+        <span class="event-time">${timeStr}</span>
+      </div>
+      <div class="event-details">
+        <div class="event-title">${event.title}</div>
+        ${event.location ? `<div class="event-location"><i class="fas fa-map-marker-alt"></i> ${event.location}</div>` : ''}
+        <span class="event-level ${levelClass}">${levelText}</span>
+        ${event.user_response ? `<span class="status-${event.user_response} event-response">Ihr Status: ${getResponseText(event.user_response)}</span>` : ''}
+      </div>
+    `;
+    
+    // Add click event
+    eventItem.addEventListener('click', function() {
+      viewEvent(event.id);
+    });
+    
+    container.appendChild(eventItem);
+  });
+}
+
+/**
+ * Convert response status to readable text
+ */
+function getResponseText(response) {
+  switch (response) {
+    case 'accepted':
+      return 'Zugesagt';
+    case 'declined':
+      return 'Abgesagt';
+    case 'tentative':
+      return 'Vielleicht';
+    default:
+      return 'Ausstehend';
+  }
+}
+
+/**
+ * View a specific event
+ */
+async function viewEvent(eventId) {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    // Fetch event details with authentication
+    const response = await fetch(`/api/calendar/${eventId}`, {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      if (response.status === 401) {
+        window.location.href = '/login.html';
+        throw new Error('Unauthorized');
+      }
+      throw new Error('Failed to load event details');
+    }
+    
+    const event = await response.json();
+    
+    // Format dates
+    const startDate = new Date(event.start_time);
+    const endDate = new Date(event.end_time);
+    
+    const formattedStartDate = startDate.toLocaleDateString('de-DE', { 
+      weekday: 'long', 
+      year: 'numeric', 
+      month: 'long', 
+      day: 'numeric' 
+    });
+    
+    const formattedEndDate = endDate.toLocaleDateString('de-DE', { 
+      weekday: 'long', 
+      year: 'numeric', 
+      month: 'long', 
+      day: 'numeric' 
+    });
+    
+    const formattedStartTime = startDate.toLocaleTimeString('de-DE', { 
+      hour: '2-digit', 
+      minute: '2-digit' 
+    });
+    
+    const formattedEndTime = endDate.toLocaleTimeString('de-DE', { 
+      hour: '2-digit', 
+      minute: '2-digit' 
+    });
+    
+    // Prepare level text
+    let levelText = 'Unbekannt';
+    if (event.org_level === 'company') {
+      levelText = 'Firma (alle Mitarbeiter)';
+    } else if (event.org_level === 'department') {
+      levelText = `Abteilung (ID: ${event.org_id})`;
+    } else if (event.org_level === 'team') {
+      levelText = `Team (ID: ${event.org_id})`;
+    }
+    
+    // Render event description with markdown
+    const renderedDescription = event.description ? marked.parse(event.description) : '';
+    
+    // Build detail view
+    const detailContent = document.getElementById('eventDetailContent');
+    detailContent.innerHTML = `
+      <div class="event-detail-header">
+        <h3>${event.title}</h3>
+        <div class="event-detail-meta">
+          Erstellt von: ${event.creator_name || 'Unbekannt'}
+        </div>
+      </div>
+      
+      <div class="event-metadata">
+        <div class="event-metadata-item">
+          <i class="fas fa-calendar"></i> 
+          ${event.all_day ? 
+            `Ganztägig, ${formattedStartDate}${startDate.toDateString() !== endDate.toDateString() ? ` bis ${formattedEndDate}` : ''}` : 
+            `${formattedStartDate}, ${formattedStartTime} - ${startDate.toDateString() !== endDate.toDateString() ? formattedEndDate + ', ' : ''} ${formattedEndTime}`
+          }
+        </div>
+        
+        ${event.location ? `
+        <div class="event-metadata-item">
+          <i class="fas fa-map-marker-alt"></i> ${event.location}
+        </div>
+        ` : ''}
+        
+        <div class="event-metadata-item">
+          <i class="fas fa-layer-group"></i> ${levelText}
+        </div>
+        
+        ${event.reminder_time ? `
+        <div class="event-metadata-item">
+          <i class="fas fa-bell"></i> Erinnerung: ${formatReminderTime(event.reminder_time)}
+        </div>
+        ` : ''}
+        
+        ${event.user_response ? `
+        <div class="event-metadata-item">
+          <i class="fas fa-reply"></i> Ihr Status: <span class="status-${event.user_response}">${getResponseText(event.user_response)}</span>
+        </div>
+        ` : ''}
+      </div>
+      
+      ${renderedDescription ? `
+      <div class="event-detail-content">
+        <h4>Beschreibung</h4>
+        ${renderedDescription}
+      </div>
+      ` : ''}
+      
+      <div class="event-attendees">
+        <h4>Teilnehmer</h4>
+        <div id="attendeesList" class="attendees-container">
+          <div class="loading-spinner"></div>
+        </div>
+      </div>
+    `;
+    
+    // Load attendees
+    loadEventAttendees(eventId, token);
+    
+    // Prepare footer buttons
+    const detailFooter = document.getElementById('eventDetailFooter');
+    
+    // Clear existing dynamic buttons
+    const existingButtons = detailFooter.querySelectorAll('button:not(.btn-secondary)');
+    existingButtons.forEach(button => button.remove());
+    
+    // Add response button if invited
+    if (event.user_response !== null) {
+      const responseButton = document.createElement('button');
+      responseButton.type = 'button';
+      responseButton.className = 'btn btn-outline-primary';
+      responseButton.textContent = 'Antworten';
+      responseButton.addEventListener('click', function() {
+        // Close detail modal and open response form
+        window.DashboardUI.closeModal('eventDetailModal');
+        openResponseForm(event);
+      });
+      
+      detailFooter.insertBefore(responseButton, detailFooter.firstChild);
+    }
+    
+    // Add edit/delete buttons for admin or creator
+    if (isAdmin || event.created_by === currentUserId) {
+      // Edit button
+      const editButton = document.createElement('button');
+      editButton.type = 'button';
+      editButton.className = 'btn btn-primary me-2';
+      editButton.textContent = 'Bearbeiten';
+      editButton.addEventListener('click', function() {
+        // Close detail modal and open edit form
+        window.DashboardUI.closeModal('eventDetailModal');
+        openEventForm(event);
+      });
+      
+      // Delete button
+      const deleteButton = document.createElement('button');
+      deleteButton.type = 'button';
+      deleteButton.className = 'btn btn-danger me-2';
+      deleteButton.textContent = 'Löschen';
+      deleteButton.addEventListener('click', function() {
+        // Close detail modal and show delete confirmation
+        window.DashboardUI.closeModal('eventDetailModal');
+        showDeleteConfirmation(event.id);
+      });
+      
+      detailFooter.insertBefore(deleteButton, detailFooter.firstChild);
+      detailFooter.insertBefore(editButton, detailFooter.firstChild);
+    }
+    
+    // Show modal
+    window.DashboardUI.openModal('eventDetailModal');
+  } catch (error) {
+    console.error('Error loading event details:', error);
+    showToast('error', 'Fehler beim Laden der Termindetails.');
+  }
+}
+
+/**
+ * Load event attendees
+ */
+async function loadEventAttendees(eventId, token) {
+  try {
+    const attendeesList = document.getElementById('attendeesList');
+    
+    // Fetch attendees
+    const response = await fetch(`/api/calendar/${eventId}/attendees`, {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      throw new Error('Failed to load attendees');
+    }
+    
+    const attendees = await response.json();
+    
+    // Clear loading spinner
+    attendeesList.innerHTML = '';
+    
+    if (attendees.length === 0) {
+      attendeesList.innerHTML = '<p class="text-center">Keine Teilnehmer gefunden.</p>';
+      return;
+    }
+    
+    // Display attendees
+    attendees.forEach(attendee => {
+      const attendeeItem = document.createElement('div');
+      attendeeItem.className = 'attendee-item';
+      
+      attendeeItem.innerHTML = `
+        <span class="attendee-name">${attendee.first_name} ${attendee.last_name}</span>
+        <span class="attendee-status status-${attendee.response_status}">${getResponseText(attendee.response_status)}</span>
+      `;
+      
+      attendeesList.appendChild(attendeeItem);
+    });
+  } catch (error) {
+    console.error('Error loading attendees:', error);
+    const attendeesList = document.getElementById('attendeesList');
+    attendeesList.innerHTML = '<p class="text-center">Fehler beim Laden der Teilnehmer.</p>';
+  }
+}
+
+/**
+ * Format reminder time
+ */
+function formatReminderTime(minutes) {
+  if (minutes >= 1440) {
+    const days = Math.floor(minutes / 1440);
+    return `${days} Tag${days > 1 ? 'e' : ''} vorher`;
+  } else if (minutes >= 60) {
+    const hours = Math.floor(minutes / 60);
+    return `${hours} Stunde${hours > 1 ? 'n' : ''} vorher`;
+  } else {
+    return `${minutes} Minute${minutes > 1 ? 'n' : ''} vorher`;
+  }
+}
+
+/**
+ * Open event form for create/edit
+ */
+function openEventForm(event = null, startDate = null, endDate = null, allDay = false) {
+  console.log("openEventForm called");
+  const formModal = document.getElementById('eventFormModal');
+  const modalTitle = document.getElementById('eventFormModalLabel');
+  const eventForm = document.getElementById('eventForm');
+  
+  // Reset form
+  eventForm.reset();
+  document.getElementById('eventOrgId').disabled = true;
+  
+  // Clear attendees
+  selectedAttendees = [];
+  document.getElementById('attendeesContainer').innerHTML = '';
+  
+  // Reset color options
+  document.querySelectorAll('.color-option').forEach(option => {
+    option.classList.remove('selected');
+  });
+  document.querySelector('.color-option[data-color="#3498db"]').classList.add('selected');
+  document.getElementById('eventColor').value = '#3498db';
+  
+  // Set form title and populate if editing
+  if (event) {
+    modalTitle.textContent = 'Termin bearbeiten';
+    
+    // Populate form fields
+    document.getElementById('eventId').value = event.id;
+    document.getElementById('eventTitle').value = event.title;
+    document.getElementById('eventDescription').value = event.description || '';
+    document.getElementById('eventLocation').value = event.location || '';
+    document.getElementById('eventAllDay').checked = event.all_day === 1;
+    document.getElementById('eventReminderTime').value = event.reminder_time || '';
+    
+    // Parse dates
+    const start = new Date(event.start_time);
+    const end = new Date(event.end_time);
+    
+    // Set date inputs (YYYY-MM-DD format)
+    document.getElementById('eventStartDate').value = start.toISOString().split('T')[0];
+    document.getElementById('eventEndDate').value = end.toISOString().split('T')[0];
+    
+    // Set time inputs (HH:MM format)
+    document.getElementById('eventStartTime').value = start.toTimeString().substring(0, 5);
+    document.getElementById('eventEndTime').value = end.toTimeString().substring(0, 5);
+    
+    // Set organization level and populate org id dropdown
+    document.getElementById('eventOrgLevel').value = event.org_level;
+    updateOrgIdDropdown(event.org_level, event.org_id);
+    
+    // Set color
+    const colorValue = event.color || '#3498db';
+    document.getElementById('eventColor').value = colorValue;
+    document.querySelectorAll('.color-option').forEach(option => {
+      option.classList.remove('selected');
+      if (option.getAttribute('data-color') === colorValue) {
+        option.classList.add('selected');
+      }
+    });
+    
+    // Toggle time inputs based on allDay
+    toggleTimeInputs(event.all_day === 1);
+    
+    // Load attendees if any
+    loadAttendees(event.id);
+  } else {
+    modalTitle.textContent = 'Neuer Termin';
+    document.getElementById('eventId').value = '';
+    
+    // If start date provided (from calendar select), use it
+    if (startDate) {
+      const start = new Date(startDate);
+      const end = endDate ? new Date(endDate) : new Date(start.getTime() + (60 * 60 * 1000)); // Default 1 hour
+      
+      // Set dates and times
+      document.getElementById('eventStartDate').value = start.toISOString().split('T')[0];
+      document.getElementById('eventEndDate').value = end.toISOString().split('T')[0];
+      
+      if (!allDay) {
+        document.getElementById('eventStartTime').value = start.toTimeString().substring(0, 5);
+        document.getElementById('eventEndTime').value = end.toTimeString().substring(0, 5);
+      }
+      
+      document.getElementById('eventAllDay').checked = allDay;
+      toggleTimeInputs(allDay);
+    } else {
+      // Default to current date and time
+      const now = new Date();
+      const later = new Date(now.getTime() + (60 * 60 * 1000)); // 1 hour later
+      
+      document.getElementById('eventStartDate').value = now.toISOString().split('T')[0];
+      document.getElementById('eventEndDate').value = now.toISOString().split('T')[0];
+      document.getElementById('eventStartTime').value = now.toTimeString().substring(0, 5);
+      document.getElementById('eventEndTime').value = later.toTimeString().substring(0, 5);
+      
+      document.getElementById('eventAllDay').checked = false;
+      toggleTimeInputs(false);
+    }
+  }
+  
+  // Show modal
+  window.DashboardUI.openModal('eventFormModal');
+}
+
+/**
+ * Toggle time inputs based on all day checkbox
+ */
+function toggleTimeInputs(isAllDay) {
+  const startTimeInput = document.getElementById('eventStartTime');
+  const endTimeInput = document.getElementById('eventEndTime');
+  
+  if (isAllDay) {
+    startTimeInput.disabled = true;
+    endTimeInput.disabled = true;
+    startTimeInput.value = '00:00';
+    endTimeInput.value = '23:59';
+  } else {
+    startTimeInput.disabled = false;
+    endTimeInput.disabled = false;
+  }
+}
+
+/**
+ * Update organization ID dropdown based on selected level
+ */
+async function updateOrgIdDropdown(level, selectedId = null) {
+  const orgIdSelect = document.getElementById('eventOrgId');
+  orgIdSelect.innerHTML = '';
+  orgIdSelect.disabled = true;
+  
+  if (level === 'company') {
+    // For company level, just add the current tenant
+    const option = document.createElement('option');
+    option.value = '1'; // Assuming tenant ID is 1
+    option.textContent = 'Gesamte Firma';
+    orgIdSelect.appendChild(option);
+    orgIdSelect.disabled = false;
+    return;
+  }
+  
+  if (level === 'department') {
+    // If departments aren't loaded yet, load them
+    if (departments.length === 0) {
+      await loadDepartmentsAndTeams();
+    }
+    
+    // Add department options
+    departments.forEach(dept => {
+      const option = document.createElement('option');
+      option.value = dept.id;
+      option.textContent = dept.name;
+      orgIdSelect.appendChild(option);
+    });
+    
+    // If admin can see all departments, otherwise restrict to user's department
+    if (!isAdmin && currentDepartmentId) {
+      // Non-admin can only post to their own department
+      orgIdSelect.value = currentDepartmentId;
+      orgIdSelect.disabled = true;
+    } else {
+      orgIdSelect.disabled = false;
+    }
+  }
+  
+  if (level === 'team') {
+    // If teams aren't loaded yet, load them
+    if (teams.length === 0) {
+      await loadDepartmentsAndTeams();
+    }
+    
+    // Add team options
+    teams.forEach(team => {
+      const option = document.createElement('option');
+      option.value = team.id;
+      option.textContent = team.name;
+      orgIdSelect.appendChild(option);
+    });
+    
+    // If admin can see all teams, otherwise restrict to user's team
+    if (!isAdmin && currentTeamId) {
+      // Non-admin can only post to their own team
+      orgIdSelect.value = currentTeamId;
+      orgIdSelect.disabled = true;
+    } else {
+      orgIdSelect.disabled = false;
+    }
+  }
+  
+  // Set selected value if provided
+  if (selectedId) {
+    orgIdSelect.value = selectedId;
+  }
+}
+
+/**
+ * Load departments and teams for dropdown
+ */
+async function loadDepartmentsAndTeams() {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    // Load departments
+    const deptResponse = await fetch('/api/departments', {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (deptResponse.ok) {
+      const deptData = await deptResponse.json();
+      departments = deptData;
+    } else if (deptResponse.status === 401) {
+      window.location.href = '/login.html';
+      throw new Error('Unauthorized');
+    }
+    
+    // Load teams
+    const teamResponse = await fetch('/api/teams', {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (teamResponse.ok) {
+      const teamData = await teamResponse.json();
+      teams = teamData;
+    } else if (teamResponse.status === 401) {
+      window.location.href = '/login.html';
+      throw new Error('Unauthorized');
+    }
+    
+    // Load employees for attendees
+    const employeeResponse = await fetch('/api/users?role=employee', {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (employeeResponse.ok) {
+      const employeeData = await employeeResponse.json();
+      employees = employeeData;
+    } else if (employeeResponse.status === 401) {
+      window.location.href = '/login.html';
+      throw new Error('Unauthorized');
+    }
+  } catch (error) {
+    console.error('Error loading reference data:', error);
+    showToast('error', 'Fehler beim Laden der Abteilungen und Teams.');
+  }
+}
+
+/**
+ * Load attendees for an event
+ */
+async function loadAttendees(eventId) {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    // Fetch attendees
+    const response = await fetch(`/api/calendar/${eventId}/attendees`, {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      throw new Error('Failed to load attendees');
+    }
+    
+    const attendees = await response.json();
+    selectedAttendees = attendees.map(att => ({
+      id: att.user_id,
+      name: `${att.first_name} ${att.last_name}`,
+      status: att.response_status
+    }));
+    
+    // Update attendees container
+    updateAttendeesContainer();
+  } catch (error) {
+    console.error('Error loading attendees:', error);
+  }
+}
+
+/**
+ * Update attendees container in the form
+ */
+function updateAttendeesContainer() {
+  const container = document.getElementById('attendeesContainer');
+  container.innerHTML = '';
+  
+  if (selectedAttendees.length === 0) {
+    container.innerHTML = '<p class="text-center text-secondary">Keine Teilnehmer hinzugefügt.</p>';
+    return;
+  }
+  
+  selectedAttendees.forEach(attendee => {
+    const attendeeItem = document.createElement('div');
+    attendeeItem.className = 'attendee-item';
+    attendeeItem.dataset.id = attendee.id;
+    
+    attendeeItem.innerHTML = `
+      <span class="attendee-name">${attendee.name}</span>
+      ${attendee.status ? 
+        `<span class="attendee-status status-${attendee.status}">${getResponseText(attendee.status)}</span>` : 
+        ''}
+      <button type="button" class="remove-attendee">
+        <i class="fas fa-times"></i>
+      </button>
+    `;
+    
+    // Add remove button event
+    const removeBtn = attendeeItem.querySelector('.remove-attendee');
+    removeBtn.addEventListener('click', function() {
+      // Remove from selected attendees
+      selectedAttendees = selectedAttendees.filter(att => att.id != attendee.id);
+      updateAttendeesContainer();
+    });
+    
+    container.appendChild(attendeeItem);
+  });
+}
+
+/**
+ * Open attendee selection modal
+ */
+function openAttendeeModal() {
+  // If employees aren't loaded yet, load them
+  if (employees.length === 0) {
+    loadDepartmentsAndTeams();
+  }
+  
+  // Clear search input
+  document.getElementById('attendeeSearch').value = '';
+  
+  // Populate attendees list
+  const attendeesList = document.getElementById('attendeesList');
+  attendeesList.innerHTML = '';
+  
+  if (employees.length === 0) {
+    attendeesList.innerHTML = '<p class="text-center">Keine Mitarbeiter gefunden.</p>';
+  } else {
+    // Filter out already selected attendees
+    const selectedIds = selectedAttendees.map(att => att.id);
+    const availableEmployees = employees.filter(emp => !selectedIds.includes(emp.id));
+    
+    if (availableEmployees.length === 0) {
+      attendeesList.innerHTML = '<p class="text-center">Alle Mitarbeiter wurden bereits hinzugefügt.</p>';
+    } else {
+      // Create checkboxes for each available employee
+      availableEmployees.forEach(emp => {
+        const item = document.createElement('div');
+        item.className = 'attendee-select-item';
+        
+        item.innerHTML = `
+          <label class="attendee-checkbox">
+            <input type="checkbox" value="${emp.id}" data-name="${emp.first_name} ${emp.last_name}">
+            <span>${emp.first_name} ${emp.last_name}</span>
+            ${emp.department_name ? `<span class="department-name">${emp.department_name}</span>` : ''}
+          </label>
+        `;
+        
+        attendeesList.appendChild(item);
+      });
+    }
+  }
+  
+  // Show modal
+  window.DashboardUI.openModal('attendeesModal');
+}
+
+/**
+ * Add selected attendees to the event
+ */
+function addSelectedAttendees() {
+  // Get all checked checkboxes
+  const checkboxes = document.querySelectorAll('#attendeesList input[type="checkbox"]:checked');
+  
+  // Add to selected attendees
+  checkboxes.forEach(checkbox => {
+    selectedAttendees.push({
+      id: checkbox.value,
+      name: checkbox.getAttribute('data-name'),
+      status: 'pending'
+    });
+  });
+  
+  // Update attendees container
+  updateAttendeesContainer();
+  
+  // Close modal
+  window.DashboardUI.closeModal('attendeesModal');
+}
+
+/**
+ * Save event (create or update)
+ */
+async function saveEvent() {
+  try {
+    // Validate form
+    const eventForm = document.getElementById('eventForm');
+    if (!eventForm.checkValidity()) {
+      eventForm.reportValidity();
+      return;
+    }
+    
+    // Get form values
+    const eventId = document.getElementById('eventId').value;
+    const title = document.getElementById('eventTitle').value.trim();
+    const description = document.getElementById('eventDescription').value.trim();
+    const location = document.getElementById('eventLocation').value.trim();
+    const startDate = document.getElementById('eventStartDate').value;
+    const startTime = document.getElementById('eventStartTime').value;
+    const endDate = document.getElementById('eventEndDate').value;
+    const endTime = document.getElementById('eventEndTime').value;
+    const allDay = document.getElementById('eventAllDay').checked;
+    const orgLevel = document.getElementById('eventOrgLevel').value;
+    const orgId = document.getElementById('eventOrgId').value;
+    const reminderTime = document.getElementById('eventReminderTime').value;
+    const color = document.getElementById('eventColor').value;
+    
+    // Combine date and time
+    const startDateTime = new Date(`${startDate}T${allDay ? '00:00' : startTime}`);
+    const endDateTime = new Date(`${endDate}T${allDay ? '23:59' : endTime}`);
+    
+    // Validate dates
+    if (startDateTime > endDateTime) {
+      showToast('error', 'Der Startzeitpunkt muss vor dem Endzeitpunkt liegen.');
+      return;
+    }
+    
+    // Prepare event data
+    const eventData = {
+      title,
+      description,
+      location,
+      start_time: startDateTime.toISOString(),
+      end_time: endDateTime.toISOString(),
+      all_day: allDay,
+      org_level: orgLevel,
+      org_id: parseInt(orgId, 10),
+      reminder_time: reminderTime,
+      color,
+      attendees: selectedAttendees.map(att => att.id)
+    };
+    
+    let url = '/api/calendar';
+    let method = 'POST';
+    
+    // If editing, use PUT method
+    if (eventId) {
+      url = `/api/calendar/${eventId}`;
+      method = 'PUT';
+    }
+    
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    // Send request with authentication
+    const response = await fetch(url, {
+      method,
+      headers: {
+        'Content-Type': 'application/json',
+        'Authorization': `Bearer ${token}`
+      },
+      body: JSON.stringify(eventData)
+    });
+    
+    if (!response.ok) {
+      throw new Error('Failed to save event');
+    }
+    
+    // Close modal and refresh calendar
+    window.DashboardUI.closeModal('eventFormModal');
+    
+    // Refresh calendar
+    calendar.refetchEvents();
+    
+    // Reload upcoming events
+    loadUpcomingEvents();
+    
+    // Show success message
+    showToast('success', eventId ? 'Termin erfolgreich aktualisiert.' : 'Neuer Termin erfolgreich erstellt.');
+  } catch (error) {
+    console.error('Error saving event:', error);
+    showToast('error', 'Fehler beim Speichern des Termins.');
+  }
+}
+
+/**
+ * Delete an event
+ */
+async function deleteEvent(eventId) {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    const response = await fetch(`/api/calendar/${eventId}`, {
+      method: 'DELETE',
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      throw new Error('Failed to delete event');
+    }
+    
+    // Refresh calendar
+    calendar.refetchEvents();
+    
+    // Reload upcoming events
+    loadUpcomingEvents();
+    
+    // Show success message
+    showToast('success', 'Termin erfolgreich gelöscht.');
+  } catch (error) {
+    console.error('Error deleting event:', error);
+    showToast('error', 'Fehler beim Löschen des Termins.');
+  }
+}
+
+/**
+ * Show delete confirmation modal
+ */
+function showDeleteConfirmation(eventId) {
+  const modal = document.getElementById('confirmationModal');
+  const confirmBtn = document.getElementById('confirmActionBtn');
+  
+  // Set modal content
+  document.getElementById('confirmationMessage').textContent = 'Möchten Sie diesen Termin wirklich löschen?';
+  document.getElementById('confirmationModalLabel').textContent = 'Termin löschen';
+  confirmBtn.textContent = 'Löschen';
+  confirmBtn.className = 'btn btn-danger';
+  
+  // Set confirm action
+  confirmBtn.onclick = function() {
+    deleteEvent(eventId);
+    window.DashboardUI.closeModal('confirmationModal');
+  };
+  
+  // Show modal
+  window.DashboardUI.openModal('confirmationModal');
+}
+
+/**
+ * Open response form to respond to an event invitation
+ */
+function openResponseForm(event) {
+  // Set event title
+  document.getElementById('responseEventTitle').textContent = event.title;
+  
+  // Setup response buttons
+  document.querySelectorAll('.response-btn').forEach(btn => {
+    const response = btn.getAttribute('data-response');
+    
+    // Highlight current response
+    if (response === event.user_response) {
+      btn.classList.add('active');
+    } else {
+      btn.classList.remove('active');
+    }
+    
+    // Add click event
+    btn.onclick = function() {
+      respondToEvent(event.id, response);
+    };
+  });
+  
+  // Show modal
+  window.DashboardUI.openModal('eventResponseModal');
+}
+
+/**
+ * Respond to an event invitation
+ */
+async function respondToEvent(eventId, response) {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    // Send response
+    const apiResponse = await fetch(`/api/calendar/${eventId}/respond`, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json',
+        'Authorization': `Bearer ${token}`
+      },
+      body: JSON.stringify({ response })
+    });
+    
+    if (!apiResponse.ok) {
+      throw new Error('Failed to respond to event');
+    }
+    
+    // Close response modal
+    window.DashboardUI.closeModal('eventResponseModal');
+    
+    // Refresh calendar
+    calendar.refetchEvents();
+    
+    // Reload upcoming events
+    loadUpcomingEvents();
+    
+    // Show success message
+    const responseText = getResponseText(response);
+    showToast('success', `Antwort "${responseText}" erfolgreich gespeichert.`);
+  } catch (error) {
+    console.error('Error responding to event:', error);
+    showToast('error', 'Fehler beim Antworten auf die Einladung.');
+  }
+}
+
+/**
+ * Setup all event listeners
+ */
+function setupEventListeners() {
+  // Filter by level using tab buttons
+  document.querySelectorAll('.tab-btn[data-value]').forEach(button => {
+    button.addEventListener('click', function() {
+      // Remove active class from all buttons
+      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
+      // Add active class to clicked button
+      this.classList.add('active');
+      
+      currentFilter = this.dataset.value;
+      
+      // Refresh calendar with new filter
+      calendar.refetchEvents();
+    });
+  });
+  
+  // Search button
+  const searchButton = document.getElementById('searchButton');
+  const searchInput = document.getElementById('searchInput');
+  
+  if (searchButton && searchInput) {
+    searchButton.addEventListener('click', function() {
+      currentSearch = searchInput.value.trim();
+      
+      // Refresh calendar with search
+      calendar.refetchEvents();
+    });
+    
+    searchInput.addEventListener('keypress', function(e) {
+      if (e.key === 'Enter') {
+        currentSearch = this.value.trim();
+        
+        // Refresh calendar with search
+        calendar.refetchEvents();
+      }
+    });
+  }
+  
+  // New event button
+  const newEventBtn = document.getElementById('newEventBtn');
+  if (newEventBtn) {
+    newEventBtn.addEventListener('click', function() {
+      openEventForm();
+    });
+  }
+  
+  // Save event button
+  const saveEventBtn = document.getElementById('saveEventBtn');
+  if (saveEventBtn) {
+    saveEventBtn.addEventListener('click', function() {
+      saveEvent();
+    });
+  }
+  
+  // Organization level change
+  const eventOrgLevel = document.getElementById('eventOrgLevel');
+  if (eventOrgLevel) {
+    eventOrgLevel.addEventListener('change', function() {
+      updateOrgIdDropdown(this.value);
+    });
+  }
+  
+  // All day checkbox
+  const allDayCheckbox = document.getElementById('eventAllDay');
+  if (allDayCheckbox) {
+    allDayCheckbox.addEventListener('change', function() {
+      toggleTimeInputs(this.checked);
+    });
+  }
+  
+  // Color picker
+  document.querySelectorAll('.color-option').forEach(option => {
+    option.addEventListener('click', function() {
+      const color = this.getAttribute('data-color');
+      document.getElementById('eventColor').value = color;
+      
+      // Remove selected class from all options
+      document.querySelectorAll('.color-option').forEach(opt => {
+        opt.classList.remove('selected');
+      });
+      
+      // Add selected class to clicked option
+      this.classList.add('selected');
+    });
+  });
+  
+  // Add attendee button
+  const addAttendeeBtn = document.getElementById('addAttendeeBtn');
+  if (addAttendeeBtn) {
+    addAttendeeBtn.addEventListener('click', function() {
+      openAttendeeModal();
+    });
+  }
+  
+  // Add selected attendees button
+  const addSelectedAttendeesBtn = document.getElementById('addSelectedAttendeesBtn');
+  if (addSelectedAttendeesBtn) {
+    addSelectedAttendeesBtn.addEventListener('click', function() {
+      addSelectedAttendees();
+    });
+  }
+  
+  // Attendee search
+  const attendeeSearch = document.getElementById('attendeeSearch');
+  if (attendeeSearch) {
+    attendeeSearch.addEventListener('input', function() {
+      const searchTerm = this.value.toLowerCase();
+      
+      // Filter attendee items
+      document.querySelectorAll('.attendee-select-item').forEach(item => {
+        const name = item.textContent.toLowerCase();
+        if (name.includes(searchTerm)) {
+          item.style.display = 'block';
+        } else {
+          item.style.display = 'none';
+        }
+      });
+    });
+  }
+  
+  // Calendar view buttons
+  document.getElementById('monthView').addEventListener('click', function() {
+    setCalendarView('dayGridMonth', this);
+  });
+  
+  document.getElementById('weekView').addEventListener('click', function() {
+    setCalendarView('timeGridWeek', this);
+  });
+  
+  document.getElementById('dayView').addEventListener('click', function() {
+    setCalendarView('timeGridDay', this);
+  });
+  
+  document.getElementById('listView').addEventListener('click', function() {
+    setCalendarView('listWeek', this);
+  });
+}
+
+/**
+ * Set calendar view
+ */
+function setCalendarView(view, button) {
+  // Update view
+  calendar.changeView(view);
+  
+  // Update button states
+  document.querySelectorAll('.view-selector button').forEach(btn => {
+    btn.classList.remove('active');
+    btn.classList.add('btn-outline-primary');
+    btn.classList.remove('btn-primary');
+  });
+  
+  button.classList.add('active');
+  button.classList.add('btn-primary');
+  button.classList.remove('btn-outline-primary');
+  
+  // Store current view
+  calendarView = view;
+}
+
+/**
+ * Fetch current user data
+ */
+async function fetchUserData() {
+  try {
+    const token = localStorage.getItem('token');
+    if (!token) {
+      throw new Error('No token found');
+    }
+    
+    const response = await fetch('/api/user/profile', {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      throw new Error('Failed to load user data');
+    }
+    
+    return await response.json();
+  } catch (error) {
+    console.error('Error fetching user data:', error);
+    throw error;
+  }
+}
+
+/**
+ * Check if user is logged in
+ */
+async function checkLoggedIn() {
+  try {
+    // Get token from localStorage
+    const token = localStorage.getItem('token');
+    if (!token) {
+      window.location.href = '/login.html';
+      throw new Error('No token found');
+    }
+    
+    const response = await fetch('/api/auth/check', {
+      headers: {
+        'Authorization': `Bearer ${token}`
+      }
+    });
+    
+    if (!response.ok) {
+      // Redirect to login page
+      window.location.href = '/login.html';
+      throw new Error('User not logged in');
+    }
+    
+    return await response.json();
+  } catch (error) {
+    console.error('Error checking login status:', error);
+    window.location.href = '/login.html';
+    throw error;
+  }
+}
+
+/**
+ * Show toast notification
+ */
+function showToast(type, message) {
+  // Use dashboard UI toast for simplified approach
+  window.DashboardUI.showToast(message, type);
+}
\ No newline at end of file
diff --git a/server/routes/calendar.js b/server/routes/calendar.js
new file mode 100644
index 0000000..e580208
--- /dev/null
+++ b/server/routes/calendar.js
@@ -0,0 +1,467 @@
+/**
+ * Calendar API Routes
+ * Handles all operations related to the company calendar system
+ */
+
+const express = require('express');
+const router = express.Router();
+const calendarModel = require('../models/calendar');
+const { authenticateToken } = require('../middleware/auth');
+const tenantMiddleware = require('../middleware/tenant');
+const { checkFeature } = require('../middleware/features');
+
+// Fallback tenant ID falls tenant middleware nicht funktioniert
+const DEFAULT_TENANT_ID = 1;
+
+// Debug log zum Überwachen der Datenbankverbindungen
+console.log("Calendar API Routes geladen - Benutze Standard-DB:", process.env.DB_NAME);
+
+// Helper function to check if user can manage the event
+async function canManageEvent(req, res, next) {
+  try {
+    const eventId = req.params.id;
+    // Use tenant ID from middleware or fallback to default
+    req.tenantId = req.tenantId || DEFAULT_TENANT_ID;
+    
+    // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+    const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+    
+    // Get user role, department, and team info for permissions
+    const userInfo = {
+      role: req.user.role,
+      departmentId: req.user.departmentId,
+      teamId: req.user.teamId
+    };
+    
+    // Check if user can manage this event
+    const canManage = await calendarModel.canManageEvent(eventId, req.user.id, userInfo);
+    
+    if (!canManage) {
+      return res.status(403).json({ 
+        message: 'You do not have permission to manage this event' 
+      });
+    }
+    
+    // Get event details for the request
+    const event = await calendarModel.getEventById(eventId, numericTenantId, req.user.id);
+    
+    if (!event) {
+      return res.status(404).json({ message: 'Event not found' });
+    }
+    
+    // Add event to request for later use
+    req.event = event;
+    next();
+  } catch (error) {
+    console.error('Error in canManageEvent middleware:', error);
+    res.status(500).json({ message: 'Internal server error' });
+  }
+}
+
+/**
+ * @route GET /api/calendar
+ * @desc Get all calendar events visible to the user
+ */
+router.get('/api/calendar', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  async (req, res) => {
+    try {
+      // Use tenant ID from middleware or fallback to default
+      req.tenantId = req.tenantId || DEFAULT_TENANT_ID;
+      
+      // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      const options = {
+        status: req.query.status || 'active',
+        filter: req.query.filter || 'all',
+        search: req.query.search || '',
+        start_date: req.query.start_date,
+        end_date: req.query.end_date,
+        page: parseInt(req.query.page || '1', 10),
+        limit: parseInt(req.query.limit || '50', 10),
+        sortBy: req.query.sortBy || 'start_time',
+        sortDir: req.query.sortDir || 'ASC'
+      };
+      
+      const result = await calendarModel.getAllEvents(numericTenantId, req.user.id, options);
+      
+      res.json(result);
+    } catch (error) {
+      console.error('Error in GET /api/calendar:', error);
+      res.status(500).json({ message: 'Error retrieving calendar events' });
+    }
+  });
+
+/**
+ * @route GET /api/calendar/dashboard
+ * @desc Get upcoming events for dashboard widget
+ */
+router.get('/api/calendar/dashboard', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  async (req, res) => {
+    try {
+      // Use tenant ID from middleware or fallback to default
+      req.tenantId = req.tenantId || DEFAULT_TENANT_ID;
+      
+      // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      const days = parseInt(req.query.days || '7', 10);
+      const limit = parseInt(req.query.limit || '5', 10);
+      
+      const events = await calendarModel.getDashboardEvents(
+        numericTenantId, 
+        req.user.id, 
+        days, 
+        limit
+      );
+      
+      res.json(events);
+    } catch (error) {
+      console.error('Error in GET /api/calendar/dashboard:', error);
+      res.status(500).json({ message: 'Error retrieving dashboard events' });
+    }
+  });
+
+/**
+ * @route GET /api/calendar/:id
+ * @desc Get a specific calendar event
+ */
+router.get('/api/calendar/:id', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  async (req, res) => {
+    try {
+      // Use tenant ID from middleware or fallback to default
+      req.tenantId = req.tenantId || DEFAULT_TENANT_ID;
+      
+      // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      const event = await calendarModel.getEventById(
+        req.params.id, 
+        numericTenantId, 
+        req.user.id
+      );
+      
+      if (!event) {
+        return res.status(404).json({ message: 'Event not found' });
+      }
+      
+      res.json(event);
+    } catch (error) {
+      console.error('Error in GET /api/calendar/:id:', error);
+      res.status(500).json({ message: 'Error retrieving calendar event' });
+    }
+});
+
+/**
+ * @route POST /api/calendar
+ * @desc Create a new calendar event
+ */
+router.post('/api/calendar', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  async (req, res) => {
+    try {
+      // Use tenant ID from middleware or fallback to default
+      req.tenantId = req.tenantId || DEFAULT_TENANT_ID;
+      
+      // Da die tenant_id in der DB ein Integer ist, müssen wir sie konvertieren
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      console.log(`Creating calendar event with tenant ID: ${numericTenantId} (konvertiert von ${req.tenantId})`);
+      
+      // Die org_id muss als Zahl vorliegen
+      let org_id = req.body.org_id;
+      if (typeof org_id === 'string') {
+        org_id = parseInt(org_id, 10);
+      }
+      
+      const eventData = {
+        tenant_id: numericTenantId,
+        title: req.body.title,
+        description: req.body.description,
+        location: req.body.location,
+        start_time: req.body.start_time,
+        end_time: req.body.end_time,
+        all_day: req.body.all_day,
+        org_level: req.body.org_level,
+        org_id: org_id,
+        created_by: req.user.id,
+        reminder_time: req.body.reminder_time,
+        color: req.body.color
+      };
+      
+      console.log("Calendar event data:", eventData);
+      
+      // Validate required fields
+      if (!eventData.title || !eventData.start_time || !eventData.end_time || 
+          !eventData.org_level || !eventData.org_id) {
+        return res.status(400).json({ 
+          message: 'Missing required fields (title, start_time, end_time, org_level, org_id)' 
+        });
+      }
+      
+      // Ensure start_time is before end_time
+      if (new Date(eventData.start_time) > new Date(eventData.end_time)) {
+        return res.status(400).json({ 
+          message: 'Start time must be before end time' 
+        });
+      }
+      
+      const event = await calendarModel.createEvent(eventData);
+      
+      // Add attendees if provided
+      if (req.body.attendees && Array.isArray(req.body.attendees)) {
+        for (const userId of req.body.attendees) {
+          await calendarModel.addEventAttendee(event.id, userId);
+        }
+        
+        // Reload event with attendees
+        const updatedEvent = await calendarModel.getEventById(
+          event.id, 
+          numericTenantId, 
+          req.user.id
+        );
+        
+        return res.status(201).json(updatedEvent);
+      }
+      
+      res.status(201).json(event);
+    } catch (error) {
+      console.error('Error in POST /api/calendar:', error);
+      res.status(500).json({ message: 'Error creating calendar event' });
+    }
+  });
+
+/**
+ * @route PUT /api/calendar/:id
+ * @desc Update a calendar event
+ */
+router.put('/api/calendar/:id', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  canManageEvent,
+  async (req, res) => {
+    try {
+      const eventData = {
+        created_by: req.user.id,
+        ...req.body
+      };
+      
+      // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      // Validate time constraints if updating times
+      if (eventData.start_time && eventData.end_time) {
+        if (new Date(eventData.start_time) > new Date(eventData.end_time)) {
+          return res.status(400).json({ message: 'Start time must be before end time' });
+        }
+      } else if (eventData.start_time && !eventData.end_time) {
+        if (new Date(eventData.start_time) > new Date(req.event.end_time)) {
+          return res.status(400).json({ message: 'Start time must be before end time' });
+        }
+      } else if (!eventData.start_time && eventData.end_time) {
+        if (new Date(req.event.start_time) > new Date(eventData.end_time)) {
+          return res.status(400).json({ message: 'Start time must be before end time' });
+        }
+      }
+      
+      const updatedEvent = await calendarModel.updateEvent(
+        req.params.id, 
+        eventData, 
+        numericTenantId
+      );
+      
+      res.json(updatedEvent);
+    } catch (error) {
+      console.error('Error in PUT /api/calendar/:id:', error);
+      res.status(500).json({ message: 'Error updating calendar event' });
+    }
+  });
+
+/**
+ * @route DELETE /api/calendar/:id
+ * @desc Delete a calendar event
+ */
+router.delete('/api/calendar/:id', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  canManageEvent,
+  async (req, res) => {
+    try {
+      // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      const success = await calendarModel.deleteEvent(req.params.id, numericTenantId);
+      
+      if (!success) {
+        return res.status(404).json({ message: 'Event not found' });
+      }
+      
+      res.json({ message: 'Event deleted successfully' });
+    } catch (error) {
+      console.error('Error in DELETE /api/calendar/:id:', error);
+      res.status(500).json({ message: 'Error deleting calendar event' });
+    }
+  });
+
+/**
+ * @route GET /api/calendar/:id/attendees
+ * @desc Get attendees for a calendar event
+ */
+router.get('/api/calendar/:id/attendees', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  async (req, res) => {
+    try {
+      // Da die tenant_id in der DB ein Integer ist, konvertieren wir auf einen Standardwert
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      // Check if event exists and user has access
+      const event = await calendarModel.getEventById(
+        req.params.id, 
+        numericTenantId, 
+        req.user.id
+      );
+      
+      if (!event) {
+        return res.status(404).json({ message: 'Event not found' });
+      }
+      
+      const attendees = await calendarModel.getEventAttendees(
+        req.params.id, 
+        numericTenantId
+      );
+      
+      res.json(attendees);
+    } catch (error) {
+      console.error('Error in GET /api/calendar/:id/attendees:', error);
+      res.status(500).json({ message: 'Error retrieving event attendees' });
+    }
+  });
+
+/**
+ * @route POST /api/calendar/:id/respond
+ * @desc Respond to a calendar event invitation
+ */
+router.post('/api/calendar/:id/respond', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  async (req, res) => {
+    try {
+      const eventId = req.params.id;
+      const userId = req.user.id;
+      const response = req.body.response;
+      
+      // Validate response
+      if (!['accepted', 'declined', 'tentative'].includes(response)) {
+        return res.status(400).json({ 
+          message: 'Invalid response. Must be "accepted", "declined", or "tentative"' 
+        });
+      }
+      
+      // Check if event exists
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      const event = await calendarModel.getEventById(eventId, numericTenantId, userId);
+      
+      if (!event) {
+        return res.status(404).json({ message: 'Event not found' });
+      }
+      
+      // Record user's response
+      await calendarModel.respondToEvent(eventId, userId, response);
+      
+      res.json({ message: 'Response recorded successfully' });
+    } catch (error) {
+      console.error('Error in POST /api/calendar/:id/respond:', error);
+      res.status(500).json({ message: 'Error responding to event' });
+    }
+  });
+
+/**
+ * @route POST /api/calendar/:id/attendees
+ * @desc Add attendees to a calendar event
+ */
+router.post('/api/calendar/:id/attendees', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  canManageEvent,
+  async (req, res) => {
+    try {
+      const eventId = req.params.id;
+      const { attendees } = req.body;
+      
+      if (!attendees || !Array.isArray(attendees) || attendees.length === 0) {
+        return res.status(400).json({ message: 'No attendees provided' });
+      }
+      
+      // Add each attendee
+      for (const userId of attendees) {
+        await calendarModel.addEventAttendee(eventId, userId);
+      }
+      
+      // Get updated attendee list
+      const numericTenantId = 1; // Standard-Tenant-ID für die Entwicklung
+      
+      const updatedAttendees = await calendarModel.getEventAttendees(
+        eventId, 
+        numericTenantId
+      );
+      
+      res.json(updatedAttendees);
+    } catch (error) {
+      console.error('Error in POST /api/calendar/:id/attendees:', error);
+      res.status(500).json({ message: 'Error adding attendees' });
+    }
+  });
+
+/**
+ * @route DELETE /api/calendar/:id/attendees/:userId
+ * @desc Remove an attendee from a calendar event
+ */
+router.delete('/api/calendar/:id/attendees/:userId', 
+  authenticateToken, 
+  tenantMiddleware, 
+  checkFeature('calendar_system'),
+  canManageEvent,
+  async (req, res) => {
+    try {
+      const eventId = req.params.id;
+      const userId = req.params.userId;
+      
+      // Allow users to remove themselves or admins to remove anyone
+      if (userId != req.user.id && req.user.role !== 'admin' && req.user.role !== 'root') {
+        return res.status(403).json({ 
+          message: 'You can only remove yourself from attendees' 
+        });
+      }
+      
+      const success = await calendarModel.removeEventAttendee(eventId, userId);
+      
+      if (!success) {
+        return res.status(404).json({ message: 'Attendee not found' });
+      }
+      
+      res.json({ message: 'Attendee removed successfully' });
+    } catch (error) {
+      console.error('Error in DELETE /api/calendar/:id/attendees/:userId:', error);
+      res.status(500).json({ message: 'Error removing attendee' });
+    }
+  });
+
+module.exports = router;
\ No newline at end of file
diff --git a/server/server.js b/server/server.js
index 87eda9a..4afec25 100644
--- a/server/server.js
+++ b/server/server.js
@@ -22,6 +22,7 @@ const featureRoutes = require('./routes/features');
 const signupRoutes = require('./routes/signup');
 const unsubscribeRoutes = require('./routes/unsubscribe');
 const blackboardRoutes = require('./routes/blackboard');
+const calendarRoutes = require('./routes/calendar');
 const authRoutes = require('./routes/auth');
 const userProfileRoutes = require('./routes/user');
 
@@ -330,6 +331,7 @@ app.use('/unsubscribe', unsubscribeRoutes); // E-Mail-Abmeldung (ohne Authentifi
 app.use('/api/auth', authRoutes); // Authentifizierungs-API
 app.use('/api/user', userProfileRoutes); // Benutzer-Profil-API
 app.use('/', blackboardRoutes); // Blackboard-System
+app.use('/', calendarRoutes); // Firmenkalender-System
 
 // Add additional API routes for departments and teams
 app.use('/api/departments', departmentRoutes);
